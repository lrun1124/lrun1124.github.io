<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/lrun1124.github.io/img/favicon.ico">

    <title>Summary - Run Note</title>

    <link rel="canonical" href="http://localhost:4000/lrun1124.github.io/2019/10/07/Summary/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/lrun1124.github.io/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/lrun1124.github.io/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/lrun1124.github.io/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/lrun1124.github.io/">Run Note</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/lrun1124.github.io/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/lrun1124.github.io/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/lrun1124.github.io/portfolio/">Portfolio</a>
                    </li>
                    
                    <li>
                        <a href="/lrun1124.github.io/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/lrun1124.github.io/img/ArrayUnique-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/lrun1124.github.io/img/ArrayUnique-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/lrun1124.github.io/tags/#JavaScript" title="JavaScript">JavaScript</a>
                        
                    </div>
                    <h1>Summary</h1>
                    
                    
                    <h2 class="subheading"></h2>
                    
                    <span class="meta">Posted by Run on October 7, 2019</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<blockquote>
  <p>“Move on. ”</p>
</blockquote>

<h2 id="js">JS</h2>
<h3 id="js基本数据类型及存储结构内置对象">JS基本数据类型及存储结构，内置对象</h3>

<ul>
  <li>Boolean, null, undefined, String, Number</li>
  <li>ES 2015 新增 : Symbol
    <ul>
      <li>独一无二的变量，由于对象中的方法属性可能在传递分享时被不小心修改或覆盖，用Symbol可以保证唯一性。let s = Symbol();</li>
    </ul>
  </li>
  <li>储存结构
    <ul>
      <li>基本(原始)数据类型在栈(stack)中存储，空间较小，大小固定，会被频繁调用；</li>
      <li>引用数据类型大小不固定，放在堆中存储</li>
    </ul>
  </li>
</ul>

<p>内置对象</p>

<p>Object对象：所有对象的父对象，原型链最上层
数据封装对象：Array, Boolean, String, Number, Object
其他： Math, Date, RegExp, Error, Function</p>

<h3 id="null-undefined区别-未声明变量"><code class="highlighter-rouge">null</code>, <code class="highlighter-rouge">undefined</code>区别, 未声明变量</h3>

<p>null表示一个对象没有值，一般是程序员显示声明，Js不会自己设置为null，typeof(null)为Object</p>

<p>undefined表示一个变量声明了，但还没有初始化， typeof(undefined)为undefined</p>

<p>null === undefined 为true, null == undefined为false，目前的JS环境中，它们的差别很小，同时存在是因为历史原因，Js初期的设计参考了C等语言，在C中，null可以自动转型为0，由于JS的设计者Brendan Eich认为‘无’的概念最好不是一个对象，并且JS早期缺乏错误处理机制，null自动转型为0可能会造成一些不被察觉的错误，所以设计了undefined</p>

<p>当你没有提前使用var、let或const声明变量，就为一个变量赋值时，该变量是未声明变量（undeclared variables）。未声明变量会脱离当前作用域，成为全局作用域下定义的变量。在严格模式下，给未声明的变量赋值，会抛出ReferenceError错误。和使用全局变量一样，使用未声明变量也是非常不好的做法，应当尽可能避免。</p>

<h3 id="js原型原型链-原型继承prototypal-inheritance的工作原理">JS原型，原型链， 原型继承（prototypal inheritance）的工作原理</h3>

<p>原型: JavaScript借鉴了面向对象语言‘一切皆是对象’的思想，对于每一个对象都存在一个prototype对象，也就是原型，prototype属性默认有一个constructor属性指向对象本身。</p>

<p><img src="http://lrun1124.github.io/img/jsbase/prototype.png" /></p>

<p>以内置对象Object为例，其prototype对象如下</p>

<p><img src="http://lrun1124.github.io/img/jsbase/objectPrototype.png" /></p>

<p>可以看到其中包括了很多常用内置方法，在其他object调用这些方法的时候就是通过原型链生效的</p>

<p>原型链: JS的继承是通过原型链实现的。当JS的对象需要某个属性的时候，首先会从当前对象的属性中去找，找不到就会到原型prototype中去找，还是找不到就会沿着原型链向上寻找，直到找到Object.prototype，如果最终找不到，则返回null</p>

<h3 id="js作用域作用域链">JS作用域，作用域链</h3>
<ul>
  <li>全局作用域
    <ul>
      <li>最外层定义的变量</li>
      <li>未定义直接赋值的变量</li>
      <li>顶层对象windows下的变量</li>
    </ul>
  </li>
  <li>局部作用域
    <ul>
      <li>var函数作用域</li>
      <li>let, const</li>
    </ul>
  </li>
</ul>

<p>JS的作用域和Java,C++之类语言最大的区别就在于它的函数作用域，对于一些熟悉Java,C++语言的人，会造成一些难以理解的结果。可以通过几个例子来看一下：</p>

<h3 id="闭包closure为什么使用闭包"><code class="highlighter-rouge">闭包（closure）</code>，为什么使用闭包</h3>

<p><strong>闭包就是能够读取其他函数内部变量的函数</strong>, 即使被外部函数返回，依然可以访问到外部（封闭）函数作用域的函数。本质上是将函数内部和外部联系起来的桥梁。</p>

<pre><code class="language-JS">function f1(){
	var n=999;
	function f2(){
		n++;
		alert(n);
	}
	return f2;
}
var result=f1();
result();//1000
result();//1001
</code></pre>

<p>以上代码通过内部的add在函数f1之外操作内部变量n，这里还体现了一个闭包的特点，可以看到在f1执行一次后n的值是被保存的，这是因为f2第一次在调用时被赋给了一个全局变量，而f2依赖于f1，所以f1的环境也始终被保存在内存中，不会被垃圾回收机制回收，所以<strong>大量使用闭包内存消耗很大，会导致性能下降</strong>&gt;，第二个要注意地方时<strong>函数内部的值可能会被修改</strong>。</p>

<p><strong>为什么使用闭包？</strong></p>

<ul>
  <li>利用闭包实现数据私有化或模拟私有方法。</li>
  <li>部分参数函数（partial applications）柯里化（currying）</li>
</ul>

<h3 id="请简述javascript中的this">请简述<code class="highlighter-rouge">JavaScript</code>中的<code class="highlighter-rouge">this</code>。</h3>

<p>JS 中的<code class="highlighter-rouge">this</code>是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了<code class="highlighter-rouge">this</code>的值。</p>

<ol>
  <li>在调用函数时使用<code class="highlighter-rouge">new</code>关键字，函数内的<code class="highlighter-rouge">this</code>是一个全新的对象。</li>
  <li>如果<code class="highlighter-rouge">apply</code>、<code class="highlighter-rouge">call</code>或<code class="highlighter-rouge">bind</code>方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。</li>
  <li>当函数作为对象里的方法被调用时，<code class="highlighter-rouge">this</code>指向直接调用者，函数内的<code class="highlighter-rouge">this</code>是调用该函数的对象。比如当<code class="highlighter-rouge">obj.method()</code>被调用时，函数内的 this 将绑定到<code class="highlighter-rouge">obj</code>对象。</li>
  <li>如果调用函数不符合上述规则，那么<code class="highlighter-rouge">this</code>的值指向全局对象（global object）。浏览器环境下<code class="highlighter-rouge">this</code>的值指向<code class="highlighter-rouge">window</code>对象，但是在严格模式下(<code class="highlighter-rouge">'use strict'</code>)，<code class="highlighter-rouge">this</code>的值为<code class="highlighter-rouge">undefined</code>。</li>
  <li>如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定<code class="highlighter-rouge">this</code>的值。</li>
  <li>如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，<code class="highlighter-rouge">this</code>被设置为它被创建时的上下文。</li>
</ol>

<h3 id="window对象和document对象"><code class="highlighter-rouge">window</code>对象和<code class="highlighter-rouge">document</code>对象</h3>

<p>window对象是浏览器打开的窗口，顶层对象，document是window对象的一个属性，HTML文档对象的一个<strong>只读引用</strong></p>

<h3 id="ie和firefox事件机制">IE和firefox事件机制</h3>

<p>IE是事件冒泡，firefox同时支持事件冒泡和捕获</p>
<ul>
  <li>事件捕获: 越高层的元素越早接收到事件，由上到下</li>
  <li>事件冒泡: 越低层的元素越早接收到时间，由下到上</li>
</ul>

<p>阻止冒泡事件的方法</p>

<pre><code class="language-JS">xxx.click = function(e){
	e.stopPropagation();
	e.cancelBubble = true;//旧IE需要
}
</code></pre>
<h3 id="new的过程"><code class="highlighter-rouge">New</code>的过程</h3>

<ol>
  <li>创建空对象；
    <ul>
      <li>var obj = {};</li>
    </ul>
  </li>
  <li>将创建出对象的原型链引用指向所要构造函数的原型；
    <ul>
      <li>obj.__proto__ = ClassA.prototype;</li>
    </ul>
  </li>
  <li>调用构造函数，this指向新实例对象：
    <ul>
      <li>ClassA.call(obj);　　//{}.构造函数();</li>
    </ul>
  </li>
  <li>将初始化完毕的新对象地址，保存到等号左边的变量中</li>
</ol>

<h3 id="不会查找原型的函数">不会查找原型的函数</h3>

<p>object.hasOwnProperty(proName), 判断对象中是否有指定名称的属性</p>

<h3 id="for-in和for-of">for in和for of</h3>

<ol>
  <li>for…in循环出的是key，for…of循环出的是value</li>
  <li>for…of是ES6对于forEach的改善，for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。for of只可以循环可迭代对象的可迭代属性，不可迭代属性在循环中被忽略了（优点1）；可以与break、continue和return配合使用。（优点2）</li>
</ol>

<p>结论：推荐在循环对象属性的时候，使用for…in,在遍历数组的时候的时候使用for…of。</p>

<h3 id="10-ajax流程手动写ajax缓存">10. Ajax流程，手动写，Ajax缓存</h3>
<p>Asynchronous JavaScript and Xml, 异步传输+JS+xml，异步的含义是在向服务器发送请求后，不必等待响应，可以先做其他的事，等相应返回可以根据设定的callback函数进行操作，于此同时，网页不会发生整页刷新，提高了效率和用户体验。</p>

<p>步骤：</p>

<ol>
  <li>创建XMLHttpRequest对象</li>
  <li>设置响应HTTP请求状态变化的函数</li>
  <li>指定该对象的的方法、URL及验证信息</li>
  <li>发送HTTP请求</li>
  <li>获取异步调用返回的数据</li>
  <li>使用JavaScript和DOM实现局部刷新</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">button</span> <span class="nx">id</span><span class="o">=</span><span class="s2">"ajaxButton"</span> <span class="nx">type</span> <span class="o">=</span><span class="s2">"button"</span><span class="o">&gt;</span><span class="nx">Make</span> <span class="nx">Ajax</span> <span class="nx">request</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>
<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="kd">var</span> <span class="nx">httpRequest</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementbyId</span><span class="p">(</span><span class="s1">'ajaxButton'</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">"click"</span><span class="p">,</span> <span class="nx">sendRequest</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">sendRequest</span><span class="p">(){</span>
	<span class="nx">httpRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span> <span class="c1">//1</span>

	<span class="k">if</span><span class="p">(</span><span class="nx">httpRequest</span><span class="p">){</span>
		<span class="nx">alert</span><span class="p">(</span><span class="s1">'Cannot creat XMLHttpRequest'</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nx">httpRequest</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nx">stateFunction</span><span class="p">;</span><span class="c1">//2</span>
	<span class="nx">httpRequest</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">'GET'</span><span class="p">,</span> <span class="s1">'test.html'</span><span class="p">);</span><span class="c1">//3</span>
	<span class="nx">httpRequest</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span><span class="c1">//4</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">stateFunction</span><span class="p">(){</span>
	<span class="k">if</span><span class="p">(</span><span class="nx">httpRequest</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="nx">XMLHttpRequet</span><span class="p">.</span><span class="nx">Done</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="nx">httpRequest</span><span class="p">.</span><span class="nx">state</span> <span class="o">===</span> <span class="mi">200</span><span class="p">){</span>
			<span class="nx">alert</span><span class="p">(</span><span class="nx">httpRequest</span><span class="p">.</span><span class="nx">responseText</span><span class="p">);</span><span class="c1">//5</span>
			<span class="c1">//... 6</span>
		<span class="p">}</span>
		<span class="k">else</span><span class="p">{</span>
			<span class="nx">alert</span><span class="p">(</span><span class="s1">'The request has some problem'</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<h3 id="11-延迟加载deferasync动态dom分组加载">11. 延迟加载，defer，async，动态dom，分组加载</h3>
<h3 id="12-get和post">12. get和post</h3>
<h3 id="13-同步和异步">13. 同步和异步</h3>
<h3 id="14-跨域问题">14. 跨域问题</h3>
<h3 id="15-前端模块化amdcmdcommonjs">15. 前端模块化，AMD/CMD/CommonJS</h3>

<p>知识点1：AMD(Asynchronous Module Definition)/CMD(Common Module Definition)/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs.</p>

<p>知识点2：CommonJs主要针对服务端，AMD/CMD主要针对浏览器端，所以最容易混淆的是AMD/CMD。（顺便提一下，针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行。这里如果有其他后端语言，如java，经验的‘玩家’应该更容易理解。而浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好。）</p>

<p>知识点3 : AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。</p>

<p>知识点4：AMD/CMD的优缺点.一个的优点就是另一个的缺点， 可以对照浏览。</p>

<p>AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。<br />
AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。</p>

<p>CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。<br />
CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。</p>

<p>知识点5：如何使用？CommonJs的话，因为nodeJs就是它的实现，所以使用node就行，也不用引入其他包。AMD则是通过&lt;script&gt;标签引入RequireJs，CMD则是引入SeaJs。</p>

<h3 id="16-内存泄漏">16. 内存泄漏</h3>
<h3 id="17---objectis区别">17. ==, ===, Object.is()区别</h3>
<h3 id="18-前端设计模式单例单体工厂策略装饰者适配器观察者门面">18. 前端设计模式，单例，单体，工厂，策略，装饰者，适配器，观察者，门面</h3>
<h3 id="19-优雅降级和渐进增强">19. 优雅降级和渐进增强</h3>
<h3 id="20-node的优缺点">20. Node的优缺点</h3>
<h3 id="21-gcv8-gc机制">21. GC，v8 GC机制</h3>
<h3 id="22-cookie和session">22. Cookie和Session</h3>
<h3 id="23-javascript继承的6种方法">23. javascript继承的6种方法</h3>
<h3 id="24-mvc和mvvm的理解">24. MVC和MVVM的理解</h3>
<h3 id="25-请解释事件委托event-delegation">25. 请解释事件委托（event delegation）</h3>

<p>将时间监听添加到父元素，而不是每个子元素单独设置，当事件冒泡到父元素，监听器就会触发，好处：</p>

<ul>
  <li>内存占用减少，只需一个父元素监听事件</li>
  <li>利于修改和维护，删除/添加的元素无需解绑和修改</li>
</ul>

<h3 id="26-foreach循环和map循环的主要区别它们分别在什么情况下使用">26. forEach循环和.map()循环的主要区别，它们分别在什么情况下使用？</h3>

<p>都是遍历数组，forEach为每个元素执行回调，最终无返回值，map每个元素返回一个新值，最后返回新数组</p>

<p>匿名函数的典型应用场景是什么？</p>

<ol>
  <li>匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 一些代码。</span>
<span class="p">})();</span>
</code></pre></div></div>
<ol>
  <li>
    <p>只使用一次的回调函数，不需要具体函数名，便于维护和提高可读性</p>
  </li>
  <li>
    <p>用于函数式编程</p>
  </li>
</ol>

<h3 id="27-宿主对象host-objects和原生对象native-objects的区别是什么">27. 宿主对象（host objects）和原生对象（native objects）的区别是什么？</h3>

<p>原生对象是由 ECMAScript 规范定义的 JavaScript 内置对象，比如<code class="highlighter-rouge">String</code>、<code class="highlighter-rouge">Math</code>、<code class="highlighter-rouge">RegExp</code>、<code class="highlighter-rouge">Object</code>、<code class="highlighter-rouge">Function</code>等等。</p>

<p>宿主对象是由运行时环境（浏览器或 Node）提供，比如<code class="highlighter-rouge">window</code>、<code class="highlighter-rouge">XMLHTTPRequest</code>等等。</p>

<h3 id="28-下列语句有什么区别function-personvar-person--person和var-person--new-person">28. 下列语句有什么区别：function Person(){}、var person = Person()和var person = new Person()？</h3>

<p>这个问题问得很含糊。我猜这是在考察 JavaScript 中的构造函数（constructor）。从技术上讲，<code class="highlighter-rouge">function Person(){}</code>只是一个普通的函数声明。使用 PascalCase 方式命名函数作为构造函数，是一个惯例。</p>

<p><code class="highlighter-rouge">var person = Person()</code>将<code class="highlighter-rouge">Person</code>以普通函数调用，而不是构造函数。如果该函数是用作构造函数的，那么这种调用方式是一种常见错误。通常情况下，构造函数不会返回任何东西，因此，像普通函数一样调用构造函数，只会返回<code class="highlighter-rouge">undefined</code>赋给用作实例的变量。</p>

<p><code class="highlighter-rouge">var person = new Person()</code>使用<code class="highlighter-rouge">new</code>操作符，创建<code class="highlighter-rouge">Person</code>对象的实例，该实例继承自<code class="highlighter-rouge">Person.prototype</code>。另外一种方式是使用<code class="highlighter-rouge">Object.create</code>，例如：<code class="highlighter-rouge">Object.create(Person.prototype)</code>。</p>

<h3 id="29-call和apply">29. call和.apply</h3>

<p>function.call(this, arg1, arg2, arg3) 
function.apply(this, [arg1, arg2, arg3]) 
this.function(arg1, arg2, arg3)</p>

<h3 id="30-functionprototypebind作用">30. Function.prototype.bind作用</h3>

<blockquote>
  <p><code class="highlighter-rouge">bind()</code>方法创建一个新的函数, 当被调用时，将其 this 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p>
</blockquote>

<h3 id="31-功能检测feature-detection功能推断feature-inference和使用-ua-字符串之间有什么区别">31. 功能检测（feature detection）、功能推断（feature inference）和使用 UA 字符串之间有什么区别？</h3>

<p><strong>功能检测（feature detection）</strong></p>

<p>功能检测包括确定浏览器是否支持某段代码，以及是否运行不同的代码（取决于它是否执行），以便浏览器始终能够正常运行代码功能，而不会在某些浏览器中出现崩溃和错误。例如：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="s1">'geolocation'</span> <span class="k">in</span> <span class="nb">navigator</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 可以使用 navigator.geolocation</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// 处理 navigator.geolocation 功能缺失</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="https://modernizr.com/">Modernizr</a>是处理功能检测的优秀工具。</p>

<p><strong>功能推断（feature inference）</strong></p>

<p>功能推断与功能检测一样，会对功能可用性进行检查，但是在判断通过后，还会使用其他功能，因为它假设其他功能也可用，例如：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>非常不推荐这种方式。功能检测更能保证万无一失。</p>

<p><strong>UA 字符串</strong></p>

<p>这是一个浏览器报告的字符串，它允许网络协议对等方（network protocol peers）识别请求用户代理的应用类型、操作系统、应用供应商和应用版本。它可以通过<code class="highlighter-rouge">navigator.userAgent</code>访问。 然而，这个字符串很难解析并且很可能存在欺骗性。例如，Chrome 会同时作为 Chrome 和 Safari 进行报告。因此，要检测 Safari，除了检查 Safari 字符串，还要检查是否存在 Chrome 字符串。不要使用这种方式。</p>

<h3 id="32-同源策略">32. 同源策略</h3>

<p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>

<h3 id="33-跨域问题">33. 跨域问题</h3>

<h4 id="jsonp">JSONP</h4>

<ul>
  <li>由于同源政策的存在，Ajax直接请求普通文件存在跨域无权限访问的问题，无论是静态页面、动态网页、web服务，只要是跨域请求，一律不准；另一方面，通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，这些拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;等标签。</li>
  <li>JSONP正是利用这一点，web客户端通过与调用脚本一模一样的方式来调用跨域服务器上的资源，服务器端则动态生成JSON，把客户端需要的数据装入进去。</li>
  <li>其缺点是只能实现get一种请求。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &lt;script&gt;
 //原生实现
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参并指定回调执行函数为onBack
    script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack';
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
 &lt;/script&gt;
</code></pre></div></div>

<p>跨来源资源共享（CORS） 是推荐的主流方式，JSONP 已被视为一种比较 hack 的方式</p>

<h4 id="postmessage">postMessage</h4>

<p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>

<ol>
  <li>页面和其打开的新窗口的数据传递</li>
  <li>多窗口之间消息传递</li>
  <li>页面与嵌套的iframe消息传递</li>
  <li>上面三个场景的跨域数据传递</li>
</ol>

<p>用法：postMessage(data,origin)方法接受两个参数</p>

<p>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br />
origin： 协议+主机+端口号，也可以设置为”*“，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/”。</p>

<p>1.）a.html：(http://www.domain1.com/a.html)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"&gt;&lt;/iframe&gt;
&lt;script&gt;       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };

    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---&gt; ' + e.data);
    }, false);
&lt;/script
</code></pre></div></div>

<p>2.）b.html：(http://www.domain2.com/b.html)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script&gt;
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---&gt; ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
&lt;/script&gt;
</code></pre></div></div>

<h4 id="34-corscross-orign-resource-share跨域资源共享">34. CORS(Cross orign resource share)跨域资源共享</h4>

<p>服务器端设置Access-Control-Allow-Origin,前端无须设置</p>

<p>“*”号表示允许任何域向我们的服务端提交请求：Access-Control-Allow-Origin：*</p>

<p>也可以设置指定的域名，如域名 http://www.test2.com ，那么就允许来自这个域名的请求：Access-Control-Allow-Origin：http://www.test2.com</p>

<p>若要带cookie请求：前后端都需要设置</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
        alert(xhr.responseText);
    }
};
</code></pre></div></div>

<h3 id="35-请解释变量提升hoisting">35. 请解释变量提升（hoisting）。</h3>

<p>使用<code class="highlighter-rouge">var</code>关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用 var 声明得到提升</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// 1</span>

<span class="c1">// 用 let/const 声明不会提升</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// ReferenceError: bar is not defined</span>
<span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p>函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升，也就是说函数不能提前调用</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 函数声明</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// [Function: foo]</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// 'FOOOOO'</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'FOOOOO'</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// [Function: foo]</span>

<span class="c1">// 函数表达式</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">bar</span><span class="p">();</span> <span class="c1">// Uncaught TypeError: bar is not a function</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'BARRRR'</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// [Function: bar]</span>
</code></pre></div></div>
<h3 id="36-请描述事件冒泡">36. 请描述事件冒泡</h3>
<p>当一个事件在 DOM 元素上触发时，如果有事件监听器，它将尝试处理该事件，然后事件冒泡到其父级元素，并发生同样的事情。最后直到事件到达祖先元素。事件冒泡是实现事件委托的原理（event delegation）。</p>

<h3 id="37-attribute-和-property-之间有什么区别">37. “attribute” 和 “property” 之间有什么区别？</h3>

<p>“Attribute” 是在 HTML 中定义的，而 “property” 是在 DOM 上定义的。为了说明区别，假设我们在 HTML 中有一个文本框：<code class="highlighter-rouge">&lt;input type="text" value="Hello"&gt;</code>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'input'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s1">'value'</span><span class="p">));</span> <span class="c1">// Hello</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// Hello</span>
</code></pre></div></div>

<p>但是在文本框中键入“ World!”后:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s1">'value'</span><span class="p">));</span> <span class="c1">// Hello</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// Hello World!</span>
</code></pre></div></div>

<h3 id="38-为什么扩展-javascript-内置对象是不好的做法">38. 为什么扩展 JavaScript 内置对象是不好的做法？</h3>

<p>扩展 JavaScript 内置（原生）对象意味着将属性或方法添加到其<code class="highlighter-rouge">prototype</code>中。虽然听起来很不错，但事实上这样做很危险。想象一下，你的代码使用了一些库，它们通过添加相同的 contains 方法来扩展<code class="highlighter-rouge">Array.prototype</code>，如果这两个方法的行为不相同，那么这些实现将会相互覆盖，你的代码将不能正常运行。</p>

<p>扩展内置对象的唯一使用场景是创建 polyfill，本质上为老版本浏览器缺失的方法提供自己的实现，该方法是由 JavaScript 规范定义的。</p>

<h3 id="39-document-中的load事件和domcontentloaded事件之间的区别是什么">39. document 中的<code class="highlighter-rouge">load</code>事件和<code class="highlighter-rouge">DOMContentLoaded</code>事件之间的区别是什么？</h3>

<ol>
  <li>
    <p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</p>
  </li>
  <li>
    <p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</p>
  </li>
</ol>

<h3 id="40-请解释单页应用是什么如何使其对-seo-友好">40. 请解释单页应用是什么，如何使其对 SEO 友好。</h3>

<p>单页面（SPA）应用是服务器端只返回一个html的web，使用客户端渲染，SPA 通过 JavaScript 来动态更新页面，这些 JavaScript 在初始页面加载时已经下载，有些爬虫程序并不会执行JS，所以不利于SEO，可以在服务器端渲染应用，首屏服务器端渲染还可以加快首屏响应速度，或者使用诸如 Prerender 的服务来“在浏览器中呈现的 javascript，保存静态 HTML，并将其返回给爬虫”。</p>

<h3 id="41-polyfill">41. polyfill</h3>

<p>我们希望浏览器提供一些特性，但是没有，然后我们自己写一段代码来实现他，那这段代码就是补丁</p>

<h3 id="42-你使用什么语句遍历对象的属性和数组的元素">42. 你使用什么语句遍历对象的属性和数组的元素？</h3>

<p>数组用forEach, for of(可break, continue), 对象遍历key用for in，不过会遍历到遍历到它的继承属性，在使用之前，需要加入obj.hasOwnProperty(property)检查</p>

<p>for…of是ES6对于forEach的改善，for of只可以循环可迭代对象的可迭代属性，不可迭代属性在循环中被忽略了（优点1）；可以与break、continue和return配合使用。（优点2）</p>

<h3 id="43-什么是事件循环调用堆栈和任务队列之间有什么区别">43. 什么是事件循环？调用堆栈和任务队列之间有什么区别？</h3>

<p>事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。</p>

<h3 id="44-请解释function-foo-和var-foo--function-之间foo的用法上的区别">44. 请解释<code class="highlighter-rouge">function foo() {}</code>和<code class="highlighter-rouge">var foo = function() {}</code>之间<code class="highlighter-rouge">foo</code>的用法上的区别。</h3>

<p>前者是函数声明，后者是函数表达式。关键的区别在于函数声明会使函数体提升（具有与变量相同的提升行为），但函数表达式的函数体不能。有关变量提升的更多解释，请参阅上面关于变量提升的问题。如果你试图在定义函数表达式之前调用它，你会得到一个<code class="highlighter-rouge">Uncaught TypeError: XXX is not a function</code>的错误。</p>

<p><strong>函数声明</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">foo</span><span class="p">();</span> <span class="c1">// 'FOOOOO'</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'FOOOOO'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>函数表达式</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">foo</span><span class="p">();</span> <span class="c1">// Uncaught TypeError: foo is not a function</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'FOOOOO'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="45-使用letvar和const创建变量有什么区别">45. 使用let、var和const创建变量有什么区别？</h3>

<ol>
  <li>用var声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数（函数作用域），也可以是声明在任何函数外的变量。let和const是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问</li>
  <li>var会使变量提升，这意味着变量可以在声明之前使用。let和const不会使变量提升，提前使用会报错。</li>
  <li>用var重复声明不会报错，但let和const会。</li>
  <li>let和const的区别在于：let允许多次赋值，而const只允许一次。</li>
</ol>

<h3 id="46-构造函数中使用箭头函数有什么好处">46. 构造函数中使用箭头函数有什么好处？</h3>
<ol>
  <li>简介</li>
  <li>正常函数的 this 是可以在执行过程中被改变的，而箭头函数的 this 则会一直保持一致。所以在使用箭头函数的时候，你就不需要担心它的上下文被改变了。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">firstName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">=</span> <span class="nx">firstName</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">sayName1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">);</span> <span class="p">};</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">sayName2</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">);</span> <span class="p">};</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">john</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">'John'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">dave</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">'Dave'</span><span class="p">);</span>

<span class="nx">john</span><span class="p">.</span><span class="nx">sayName1</span><span class="p">();</span> <span class="c1">// John</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">sayName2</span><span class="p">();</span> <span class="c1">// John</span>

<span class="c1">// 普通函数的 this 可以被修改，而箭头函数则不会</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">sayName1</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">dave</span><span class="p">);</span> <span class="c1">// Dave (因为 "this" 现在指向了 dave 对象)</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">sayName2</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">dave</span><span class="p">);</span> <span class="c1">// John</span>

<span class="nx">john</span><span class="p">.</span><span class="nx">sayName1</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">dave</span><span class="p">);</span> <span class="c1">// Dave (因为 "this" 现在指向了 dave 对象)</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">sayName2</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">dave</span><span class="p">);</span> <span class="c1">// John</span>

<span class="nx">john</span><span class="p">.</span><span class="nx">sayName1</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">dave</span><span class="p">)();</span> <span class="c1">// Dave (因为 "this" 现在指向了 dave 对象)</span>
<span class="nx">john</span><span class="p">.</span><span class="nx">sayName2</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">dave</span><span class="p">)();</span> <span class="c1">// John</span>

<span class="kd">var</span> <span class="nx">sayNameFromWindow1</span> <span class="o">=</span> <span class="nx">john</span><span class="p">.</span><span class="nx">sayName1</span><span class="p">;</span>
<span class="nx">sayNameFromWindow1</span><span class="p">();</span> <span class="c1">// undefined (因为 "this" 现在指向了 Window 对象)</span>

<span class="kd">var</span> <span class="nx">sayNameFromWindow2</span> <span class="o">=</span> <span class="nx">john</span><span class="p">.</span><span class="nx">sayName2</span><span class="p">;</span>
<span class="nx">sayNameFromWindow2</span><span class="p">();</span> <span class="c1">// John</span>
</code></pre></div></div>

<p>这在 React 的类组件里非常有用。如果你使用普通的函数来定义一个类方法，比如一个点击处理函数，然后你将这个点击处理函数通过 prop 的形式传递给子节点，你将必须在父组件的 <code class="highlighter-rouge">constroctor</code> 里使用 <code class="highlighter-rouge">fn.bind(this)</code> 的形式来确保该函数能正常工作。但是如果你使用箭头函数的话，你就不需要手动去绑定 <code class="highlighter-rouge">this</code> 了，因为箭头函数会自动绑定创建时的 <code class="highlighter-rouge">this</code>。</p>

<h3 id="47-请给出一个解构destructuring对象或数组的例子">47. 请给出一个解构（destructuring）对象或数组的例子。</h3>

<p>解构是 ES6 中新功能，它提供了一种简洁方便的方法来提取对象或数组的值，并将它们放入不同的变量中。</p>

<p><strong>数组解构</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 变量赋值</span>
<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'one'</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">];</span>

<span class="kd">const</span> <span class="p">[</span><span class="nx">one</span><span class="p">,</span> <span class="nx">two</span><span class="p">,</span> <span class="nx">three</span><span class="p">]</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">one</span><span class="p">);</span> <span class="c1">// "one"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">two</span><span class="p">);</span> <span class="c1">// "two"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">three</span><span class="p">);</span> <span class="c1">// "three"</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 变量交换</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p><strong>对象解构</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 变量赋值</span>
<span class="kd">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="na">p</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span> <span class="na">q</span><span class="p">:</span> <span class="kc">true</span> <span class="p">};</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// 42</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">q</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="html">html</h3>
<h3 id="1-事件冒泡和捕获">1. 事件冒泡和捕获</h3>
<h3 id="2-window对象和document对象">2. window对象和document对象</h3>
<h3 id="3-页面编码和被请求的资源编码如果不一致">3. 页面编码和被请求的资源编码如果不一致</h3>
<h3 id="4-dom操作">4. DOM操作</h3>
<h3 id="5-把-script-标签-放在页面的最底部的body封闭之前-和封闭之后有什么区别">5. 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？</h3>
<h3 id="6-给一个dom同时绑定两个点击事件一个用捕获一个用冒泡会执行几次事件">6. 给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件？</h3>
<h3 id="7-http状态码">7. http状态码</h3>
<h3 id="8-doctype作用">8. Doctype作用</h3>
<h3 id="9-标准模式与兼容模式有什么区别">9. 标准模式与兼容模式有什么区别</h3>
<h3 id="10-html5-为什么只需要写-doctype-html">10. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;</h3>
<h3 id="11-行内元素有哪些块级元素有哪些-空void元素有那些">11. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3>
<h3 id="12-使用link和import区别">12. 使用link和@import区别</h3>
<h3 id="13-浏览器内核的理解">13. 浏览器内核的理解</h3>
<h3 id="14-常见的浏览器内核">14. 常见的浏览器内核</h3>
<h3 id="15-html5有哪些新特性如何处理html5新标签的浏览器兼容问题如何区分-html-和-html5">15. html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3>
<h3 id="16-xmlsgmlhtmlxhtmlhtml5">16. XML,SGML,HTML,XHTML,HTML5</h3>
<h3 id="17-html语义化">17. HTML语义化</h3>
<h3 id="18-cookie-loaclstorage-sessionstorage">18. cookie, loaclStorage, sessionStorage</h3>
<h3 id="19-浏览器是怎么对html5的离线储存资源进行管理和加载的呢">19. 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h3>
<h3 id="20-iframe缺点">20. iframe缺点</h3>
<h3 id="21-label的作用是什么是怎么用的">21. Label的作用是什么？是怎么用的？</h3>
<h3 id="22-title与h1的区别b与strong的区别i与em的区别">22. title与h1的区别、b与strong的区别、i与em的区别？</h3>
<h3 id="23-如何实现浏览器内多个标签页之间的通信">23. 如何实现浏览器内多个标签页之间的通信?</h3>
<h3 id="24-javascript是采用值传递还是引用传递的并解释一下原理">24. JavaScript是采用值传递还是引用传递的，并解释一下原理</h3>

<h3 id="css">css</h3>
<h3 id="1-css的盒子模型低版本ie的盒子模型有什么不同的">1. CSS的盒子模型，低版本IE的盒子模型有什么不同的</h3>
<h3 id="2-css选择器">2. CSS选择器</h3>
<h3 id="3-display的值及作用">3. display的值及作用</h3>
<h3 id="4-position属性定位原点">4. position属性（定位原点）</h3>
<h3 id="5-居中div-水平居中水平垂直居中">5. 居中div, 水平居中，水平垂直居中</h3>
<h3 id="6-flexbox">6. Flexbox</h3>
<h3 id="7-用纯css创建三角形">7. 用纯css创建三角形</h3>
<h3 id="8-清除浮动">8. 清除浮动</h3>
<h3 id="9-css优化提高性能的方式">9. CSS优化、提高性能的方式</h3>
<h3 id="10">10.</h3>

<h3 id="性能优化">性能优化</h3>
<h3 id="1-一个页面从输入-url-到页面加载显示完成这个过程中都发生了什么">1. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h3>
<h3 id="2-性能优化策略-核心html层面布局-request-css-服务器端-js">2. 性能优化策略, 核心，html层面布局， request, css, 服务器端, JS</h3>

<h3 id="other">other</h3>
<h3 id="1-对称非对称加密公钥和私钥">1. 对称/非对称加密，公钥和私钥</h3>
<h3 id="2-xml和json的区别">2. XML和JSON的区别？</h3>
<h3 id="3-json了解">3. JSON了解</h3>
<h3 id="4-web安全及防护原理-sql注入-xss-csrf">4. Web安全及防护原理, sql注入, XSS, csrf</h3>

<h3 id="code">code</h3>



                <hr>

                
                <!-- 多说 Share start -->
                </style>
                <div class="ds-share"
                    style="text-align: right"
                    data-thread-key="/2019/10/07/Summary"
                    data-title="Summary"
                    data-url="http://localhost:4000/lrun1124.github.io/2019/10/07/Summary/"
                    data-images="http://localhost:4000/lrun1124.github.io/img/ArrayUnique-bg.jpg"
                    data-content="
  “Move on. ”


JS
JS基本数据类型及存储结构，内置对象


  Boolean, null, undefined, String, ... | Run Note " >
                    <div class="ds-share-inline">
                      <ul  class="ds-share-icons-16">
                        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li>
                        <li><a class="ds-wechat flat" href="javascript:void(0);" data-service="wechat">微信</a></li>
                        <li><a class="ds-weibo flat" href="javascript:void(0);" data-service="weibo">微博</a></li>
                        <li><a class="ds-douban flat" href="javascript:void(0);" data-service="douban">豆瓣</a></li>
                      </ul>
                      <div class="ds-share-icons-more">
                      </div>
                    </div>
                <hr>
                </div>
                <!-- 多说 Share end-->
                


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/lrun1124.github.io/2019/09/04/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" data-toggle="tooltip" data-placement="top" title="性能优化">&larr; Previous Post</a>
                    </li>
                    
                    
                </ul>


                
                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread"
                        data-thread-key="/2019/10/07/Summary"
                        data-title="Summary"
                        data-url="http://localhost:4000/lrun1124.github.io/2019/10/07/Summary/" >
                    </div>
                </div>
                <!-- 多说评论框 end -->
                

                

            </div>

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
        				
                            
                				<a href="/lrun1124.github.io/tags/#JavaScript" title="JavaScript" rel="12">
                                    JavaScript
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="#">Foo</a></li>
                    
                        <li><a href="#">Bar</a></li>
                    
                        <li><a href="#">Example Friends</a></li>
                    
                        <li><a href="#">It helps SEO</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>


<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    // dynamic User by Hux
    var _user = 'run';

    // duoshuo comment query.
    var duoshuoQuery = {short_name: _user };
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/lrun">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    <li>
                        <a target="_blank" href="https://www.facebook.com/lrun">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/lrun1124">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Run Note 2019
<!--                     <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true" >
                    </iframe> -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/lrun1124.github.io/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/lrun1124.github.io/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/lrun1124.github.io/js/hux-blog.min.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-49627206-1';
    var _gaDomain = 'huangxuan.me';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '4cc1f2d8f3067386cc5cdb626a202900';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>

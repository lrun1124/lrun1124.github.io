<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Run Note</title>
    <description></description>
    <link>http://localhost:4000/lrun1124.github.io/</link>
    <atom:link href="http://localhost:4000/lrun1124.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 13 Nov 2017 22:21:46 +0800</pubDate>
    <lastBuildDate>Mon, 13 Nov 2017 22:21:46 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>JavaScript基础(一)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Step 1. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;转前端工作一年多后对JS的一些基础仍然存在盲区，记录一些note查漏补缺&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;js基本数据类型&quot;&gt;JS基本数据类型&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Boolean, null, undefined, String, Number&lt;/li&gt;
  &lt;li&gt;ES 2015 新增 : Symbol
    &lt;ul&gt;
      &lt;li&gt;独一无二的变量，由于对象中的方法属性可能在传递分享时被不小心修改或覆盖，用Symbol可以保证唯一性。let s = Symbol();&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;js内置对象&quot;&gt;JS内置对象&lt;/h3&gt;

&lt;p&gt;Object对象：所有对象的父对象，原型链最上层
数据封装对象：Array, Boolean, String, Number, Object
其他： Math, Date, RegExp, Error, Function&lt;/p&gt;

&lt;h3 id=&quot;null-undefined区别&quot;&gt;null, undefined区别&lt;/h3&gt;

&lt;p&gt;null表示一个对象没有值，一般是程序员显示声明，Js不会自己设置为null，typeof(null)为Object&lt;/p&gt;

&lt;p&gt;undefined表示一个变量声明了，但还没有初始化， typeof(undefined)为undefined&lt;/p&gt;

&lt;p&gt;null === undefined 为true, null == undefined为false，目前的JS环境中，它们的差别很小，同时存在是因为历史原因，Js初期的设计参考了C等语言，在C中，null可以自动转型为0，由于JS的设计者Brendan Eich认为‘无’的概念最好不是一个对象，并且JS早期缺乏错误处理机制，null自动转型为0可能会造成一些不被察觉的错误，所以设计了undefined&lt;/p&gt;

&lt;h3 id=&quot;js原型原型链&quot;&gt;JS原型，原型链&lt;/h3&gt;

&lt;p&gt;原型: JavaScript借鉴了面向对象语言‘一切皆是对象’的思想，对于每一个对象都存在一个prototype对象，也就是原型，prototype属性默认有一个constructor属性指向对象本身。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/lrun1124.github.io/img/jsbase/prototype.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以内置对象Object为例，其prototype对象如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/lrun1124.github.io/img/jsbase/objectPrototype.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到其中包括了很多常用内置方法，在其他object调用这些方法的时候就是通过原型链生效的&lt;/p&gt;

&lt;p&gt;原型链: JS的继承是通过原型链实现的。当JS的对象需要某个属性的时候，首先会从当前对象的属性中去找，找不到就会到原型prototyoe中去找，还是找不到就会沿着原型链向上寻找，直到找到Object.prototype，如果最终找不到，则返回null&lt;/p&gt;

&lt;h3 id=&quot;作用域&quot;&gt;作用域&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;全局作用域
    &lt;ul&gt;
      &lt;li&gt;最外层定义的变量&lt;/li&gt;
      &lt;li&gt;未定义直接赋值的变量&lt;/li&gt;
      &lt;li&gt;顶层对象windows下的变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;局部作用域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JS的作用域和Java,C++之类语言最大的区别就在于它的函数作用域，对于一些熟悉Java,C++语言的人，会造成一些难以理解的结果。可以通过几个例子来看一下：&lt;/p&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i = 'out';
var test = function(){
	console.log(i);
	var i = 'in';
	console.log(i);
}
test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里运行结果是&lt;br /&gt;
undefined&lt;br /&gt;
in&lt;br /&gt;
而不是&lt;br /&gt;
out&lt;br /&gt;in&lt;/p&gt;

&lt;p&gt;code2：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i = 'out';
if(true){
	var i = 'in'
	console.log(i);
}
console.log(i);

test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里运行结果是&lt;br /&gt;
in&lt;br /&gt;
in&lt;br /&gt;
而不是&lt;br /&gt;
in&lt;br /&gt;
out&lt;/p&gt;

&lt;p&gt;造成结果的原因都是因为JS的函数作用域，所谓函数作用域：&lt;strong&gt;变量在其所声明的函数内的任意位置都是可访问的&lt;/strong&gt;，这里就引出了JS变量的函数提升，对于code1，其实际的执行code可以改写如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i = 'out';
var test = function(){
	var i;
	console.log(i);
	i = 'in';
	console.log(i);
}
test();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到变量i的声明在函数内部是被提升到了开始的位置，但是赋值的位置确是不变的。类似的code2可以改写为:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i;
var i; 
i = 'out';
if(true){
	i = 'in'
	console.log(i);
}
console.log(i);

test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;i在if中被修改了&lt;/p&gt;

&lt;h3 id=&quot;作用域链&quot;&gt;作用域链&lt;/h3&gt;

&lt;p&gt;当代码在环境中执行的时候，会创建变量对象的一个作用域链（scope chain）。其用途是&lt;strong&gt;保证能够有序访问当前环境中的变量和函数&lt;/strong&gt;。作用域链的前端始终是当前代码所在的变量对象，下一个变量对象总是外部环境的变量对象。&lt;strong&gt;标识符解析时,总是沿着作用域链从前端向后逐层的搜索&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;环境之前的联系是&lt;strong&gt;线性有序&lt;/strong&gt;的,内部环境是可以通过作用域链访问所有外部环境，但是外部环境不能访问内部环境。所以引发了&lt;strong&gt;闭包&lt;/strong&gt;的概念&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;另使用with可以在作用域顶端添加某个对象，因为有可能造成混淆和兼容错误，所以不被推荐使用，不过在某些情况下可以减少不必要的作用域链搜索过程并简化代码，当然，这种简化方式用一个指针也可以做到。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var a, x, y;
var r = 10;

with (Math) {
  a = PI * r * r;
  x = r * cos(PI);
  y = r * sin(PI / 2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;闭包&quot;&gt;闭包&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;闭包就是能够读取其他函数内部变量的函数&lt;/strong&gt;, 本质上是将函数内部和外部联系起来的桥梁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;function f1(){
	var n=999;
	function add(){
		n++;
		alert(n);
	}
	return add;
}
var result=f1();
result();//1000
result();//1001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码通过内部的add在函数f1之外操作内部变量n，这里还体现了一个闭包的特点，可以看到在f1执行一次后n的值是被保存的，这是因为f2第一次在调用时被赋给了一个全局变量，而f2依赖于f1，所以f1的环境也始终被保存在内存中，不会被垃圾回收机制回收，所以&lt;strong&gt;大量使用闭包内存消耗很大，会导致性能下降&lt;/strong&gt;&amp;gt;，第二个要注意地方时&lt;strong&gt;函数内部的值可能会被修改&lt;/strong&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript%E5%9F%BA%E7%A1%80(%E4%B8%80)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript%E5%9F%BA%E7%A1%80(%E4%B8%80)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>Array去重的多种实现和分析</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Move on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;有趣的小问题，似乎经常在面试中出现&lt;/p&gt;

&lt;h3 id=&quot;方法一-双层循环&quot;&gt;方法一: 双层循环&lt;/h3&gt;

&lt;p&gt;外层循环遍历数组，内层循环判断重复，检测到重复即break，无重复则Push进结果数组。&lt;/p&gt;

&lt;p&gt;利用Array.prototype.indexOf()可以简化如下：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度O(n^2)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;方法二-排序&quot;&gt;方法二: 排序&lt;/h3&gt;

&lt;p&gt;先排序后从第二项循环，和前一项不同则加入&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度O(log(n)+n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;方法三-利用hash&quot;&gt;方法三: 利用hash&lt;/h3&gt;

&lt;p&gt;使用一个Object做hash，循环检测当前想是否在hash中，没有则加入hash并加入数组&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; 
		&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
		 	&lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		 	&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;时间复杂度O(n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;方法四-利用es6的set&quot;&gt;方法四: 利用ES6的Set&lt;/h3&gt;

&lt;p&gt;数组构造set会自动去重，set再展开为数组，代码最简洁&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;Array.prototype.unique = function(){
	return [...new Set(this)];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;效率分析&quot;&gt;效率分析&lt;/h2&gt;

&lt;p&gt;使用随机函数分别生成length为10^3，10^4，10^5，10^6的随机数，范围为0-500的整数。&lt;/p&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;p&gt;10^3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^3.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10^4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^4.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10^5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^5.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10^6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^6.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;

&lt;p&gt;可以看到前两种方法使用的时间比后两种高一个数量级，相对而言，第二种排序的方法最耗时；而后两种中，使用set的方法比使用hash的方法更加耗时，所以从耗时的角度，最好的是使用方法三，即使用hash记录，从代码简洁的角度，利用set的机制最好，并且耗时和方法三也在一个数量级。&lt;/p&gt;

&lt;h3 id=&quot;test-code&quot;&gt;Test code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;Array.prototype.unique1 = function() {
	var res = [];
	this.forEach(function(item){
		if(res.indexOf(item) &amp;lt; 0){
			res.push(item);
		}
	});
	return res;
};


Array.prototype.unique2 = function() {
	var res = [this[0]];
	this.sort();
	for(let i = 1; i &amp;lt; this.length; i++){
		if(this[i] !== this[i-1]){
			res.push(this[i])
		}
	}
	return res;
};

Array.prototype.unique3 = function() {
	var hash = {}, 
		res = [];
	this.forEach(function(item){
		if(!hash[item]){
		 	hash[item] = true;
		 	res.push(item);
		}
	});
	return res;
};

Array.prototype.unique4 = function(){
	return [...new Set(this)];
}

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive
}

var count = 10000000;
var testArray = [];
for(let i =0 ; i &amp;lt; count; i++){
	testArray.push(getRandomInt(0,500))
}
var start = new Date().getTime();
console.log(testArray.unique1());
var end = new Date().getTime();
console.log(&quot;unique1: &quot; + (end - start) + &quot;ms&quot;);

var start = new Date().getTime();
console.log(testArray.unique2());
var end = new Date().getTime();
console.log(&quot;unique2: &quot; + (end - start) + &quot;ms&quot;);

var start = new Date().getTime();
console.log(testArray.unique3());
var end = new Date().getTime();
console.log(&quot;unique3: &quot; + (end - start) + &quot;ms&quot;);

var start = new Date().getTime();
console.log(testArray.unique4());
var end = new Date().getTime();
console.log(&quot;unique4: &quot; + (end - start) + &quot;ms&quot;);
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/Array%E5%8E%BB%E9%87%8D%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/Array%E5%8E%BB%E9%87%8D%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>Walkways Problem</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;前段时间看到一篇文章，其中讨论了陶哲轩（Terrence Tao）blog上提出的一个数学问题，文章并没有给出明确的解答，在此记录自己的一点思考：&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;Suppose you are trying to get from one end A of a terminal to the other end B. (For simplicity, assume the terminal is a one-dimensional line segment.) Some portions of the terminal have moving walkways (in both directions); other portions do not. Your walking speed is a constant v, but while on a walkway, it is boosted by the speed u of the walkway for a net speed of v+u. (Obviously, given a choice, one would only take those walkways that are going in the direction one wishes to travel in.) Your objective is to get from A to B in the shortest time possible.&lt;/p&gt;

&lt;p&gt;在机场中，你想从A点前往B点。（为了将问题简化，假设机场是一条线性通道。）一些区域有电动扶梯（双向的），另一些区域没有。你的步行速度恒定为v，电动扶梯的运行速度为u，因此在扶梯上，你的实际速度为v+u。（显然，你不会搭乘与你前进方向不一致的扶梯。）你的目标是尽可能快地从A点到达B点。&lt;/p&gt;

&lt;h3 id=&quot;问题1&quot;&gt;问题1&lt;/h3&gt;
&lt;p&gt;Suppose you need to pause for some period of time, say to tie your shoe. Is it more efficient to do so while on a walkway, or off the walkway? Assume the period of time required is the same in both cases.&lt;/p&gt;

&lt;p&gt;假定你需要暂停片刻，比如系鞋带。请问你应该在电动扶梯上系，还是在没有上电动扶梯时系？假定两种情况下，系鞋带的时间相同。&lt;/p&gt;

&lt;h3 id=&quot;问题2&quot;&gt;问题2&lt;/h3&gt;
&lt;p&gt;Suppose you have a limited amount of energy available to run and increase your speed to a higher quantity v’ (or v’+u, if you are on a walkway). Is it more efficient to run while on a walkway, or off the walkway? Assume that the energy expenditure is the same in both cases.&lt;/p&gt;

&lt;p&gt;假定你有有限数量的多余能量，用来奔跑。在跑动时，你的速度提高到v’（如果在电动扶梯上，就相应为v’+u）。请问你应该在电动扶梯上跑，还是在没有上电动扶梯时跑？假定两种情况下，你可供奔跑的能量相同。&lt;/p&gt;

&lt;h3 id=&quot;问题3&quot;&gt;问题3&lt;/h3&gt;
&lt;p&gt;Do the answers to the above questions change if one takes into account the various effects of special relativity? (This is of course an academic question rather than a practical one. But presumably it should be the time in the airport frame that one wants to minimise, not time in one’s personal frame.)&lt;/p&gt;

&lt;p&gt;在狭义相对论的情况下，上述答案是否发生改变？&lt;/p&gt;

&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;

&lt;p&gt;首先，第一问很简单，肯定是在电梯上，主要讨论第二问：&lt;/p&gt;

&lt;p&gt;设想有3个人，A不加速，B行走时加速，C扶梯时加速。加速值记为dV，加速时间记为dT。&lt;/p&gt;

&lt;p&gt;假设A和B先比赛，从起点到终点A和B都是先扶梯再走路，A和B同时下扶梯，B到终点时，A落后 dS=dV*dT 距离，相当于B领先A dS/v 时间。&lt;/p&gt;

&lt;p&gt;假设A和C后比赛，是同一段路反向走，即先走路后电梯，则A与C同一时间走上扶梯，C到终点（也是扶梯终点）时，A仍然落后 dS=dV*dT 距离，但A只用 dS/(v+u) 时间即可到达终点
由于是同一段路A只是正反向走
因此，B最快，C次之，A最慢。&lt;/p&gt;

&lt;p&gt;还可以这么解释我觉得也不错，时间是匀速流逝的前提下，当然是要充分利用传送带，因为传送带的长度是固定，所以鞋带留在传送带上系，加速在地面来做。属于一种“边际效益递减”。&lt;/p&gt;

&lt;hr /&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/Walkways-Problem/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/Walkways-Problem/</guid>
        
        <category>Math</category>
        
        
      </item>
    
  </channel>
</rss>

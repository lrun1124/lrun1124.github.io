<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Run Note</title>
    <description></description>
    <link>http://localhost:4000/lrun1124.github.io/</link>
    <atom:link href="http://localhost:4000/lrun1124.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 14 Dec 2017 17:24:47 +0800</pubDate>
    <lastBuildDate>Thu, 14 Dec 2017 17:24:47 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>Css Note</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;CSS的盒子模型，低版本IE的盒子模型有什么不同的？&lt;/p&gt;

&lt;p&gt;W3C标准盒子模型，content(内容)，padding(内边距)，border(边框)，margin(外边距)组成&lt;/p&gt;

&lt;p&gt;以margin：10px； border：2px； padding：5px； width：200px；height：100px 为例&lt;/p&gt;

&lt;p&gt;则整个盒子模型的宽是：10px&lt;em&gt;2 + 2px&lt;/em&gt;2 + 5px*2 + 200px = 234px&lt;/p&gt;

&lt;p&gt;则整个盒子模型的高是：10px&lt;em&gt;2 + 2px&lt;/em&gt;2 + 5px*2 + 100px = 134px&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/lrun1124.github.io/img/cssbase1/boxModelW3C.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;旧IE，主要是指IE5和（IE6的怪异模式），content部分的width和height是把padding和border也算了进去&lt;/p&gt;

&lt;p&gt;整个盒子模型的宽是： margin*2 + width（严格来说是：margin-left + width + margin-right&lt;/p&gt;

&lt;p&gt;整个盒子模型的高是： margin*2 + height（严格来说是：margin-left + height + margin-right）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/lrun1124.github.io/img/cssbase1/boxModelOldIE.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;CSS选择器&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;id选择器（# myid）&lt;/li&gt;
  &lt;li&gt;类选择器（.myclassname）&lt;/li&gt;
  &lt;li&gt;标签选择器（div, h1, p）&lt;/li&gt;
  &lt;li&gt;相邻选择器（h1 + p）&lt;/li&gt;
  &lt;li&gt;子选择器（ul &amp;gt; li）&lt;/li&gt;
  &lt;li&gt;后代选择器（li a）&lt;/li&gt;
  &lt;li&gt;通配符选择器（ * ）&lt;/li&gt;
  &lt;li&gt;属性选择器（a[rel = “external”]）&lt;/li&gt;
  &lt;li&gt;伪类选择器（a:hover, li:nth-child&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;display的值及作用&quot;&gt;display的值及作用&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;block       	块类型。默认宽度为父元素宽度，可设置宽高，换行显示。&lt;/li&gt;
  &lt;li&gt;none        	缺省值。象行内元素类型一样显示。&lt;/li&gt;
  &lt;li&gt;inline      	行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。&lt;/li&gt;
  &lt;li&gt;inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。&lt;/li&gt;
  &lt;li&gt;list-item   	象块类型元素一样显示，并添加样式列表标记。&lt;/li&gt;
  &lt;li&gt;table       	此元素会作为块级表格来显示。&lt;/li&gt;
  &lt;li&gt;inherit     	规定应该从父元素继承 display 属性的值。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 07 Dec 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/12/07/CSS-Note(1)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/12/07/CSS-Note(1)/</guid>
        
        <category>CSS</category>
        
        
      </item>
    
      <item>
        <title>Html Note</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;Doctype作用？标准模式与兼容模式各有什么区别?&lt;/p&gt;

&lt;p&gt;（1）、&amp;lt;!DOCTYPE&amp;gt;声明位于位于HTML文档中的第一行，处于 &amp;lt;html&amp;gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。&lt;/p&gt;

&lt;p&gt;（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;HTML5 为什么只需要写 &amp;lt;!DOCTYPE HTML&amp;gt;？&lt;/p&gt;

&lt;p&gt;HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；&lt;/p&gt;

&lt;p&gt;而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。&lt;/p&gt;

&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;

&lt;p&gt;行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？&lt;/p&gt;

&lt;p&gt;首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。&lt;/p&gt;

&lt;p&gt;（1）行内元素有：a b span img input select strong（强调的语气）&lt;/p&gt;

&lt;p&gt;（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p&lt;/p&gt;

&lt;p&gt;（3）常见的空元素：&amp;lt;br&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;img&amp;gt; &amp;lt;input&amp;gt; &amp;lt;link&amp;gt; &amp;lt;meta&amp;gt;&lt;/p&gt;

  	鲜为人知的是：&amp;lt;area&amp;gt; &amp;lt;base&amp;gt; &amp;lt;col&amp;gt; &amp;lt;command&amp;gt; &amp;lt;embed&amp;gt; &amp;lt;keygen&amp;gt; &amp;lt;param&amp;gt; &amp;lt;source&amp;gt; &amp;lt;track&amp;gt; &amp;lt;wbr&amp;gt;

&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;

&lt;p&gt;页面导入样式时，使用link和@import有什么区别？&lt;/p&gt;

&lt;p&gt;（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;&lt;/p&gt;

&lt;p&gt;（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;&lt;/p&gt;

&lt;p&gt;（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;&lt;/p&gt;

&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;

&lt;p&gt;介绍一下你对浏览器内核的理解？&lt;/p&gt;

&lt;p&gt;主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。&lt;/p&gt;

&lt;p&gt;渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。&lt;/p&gt;

&lt;p&gt;JS引擎：解析和执行javascript来实现网页的动态效果。&lt;/p&gt;

&lt;p&gt;最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。&lt;/p&gt;

&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;

&lt;p&gt;常见的浏览器内核有哪些？&lt;/p&gt;

&lt;p&gt;Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]&lt;br /&gt;
  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]&lt;/p&gt;

&lt;h3 id=&quot;7&quot;&gt;7&lt;/h3&gt;

&lt;p&gt;html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
    &lt;ol&gt;
      &lt;li&gt;绘画 canvas;&lt;/li&gt;
      &lt;li&gt;用于媒介回放的 video 和 audio 元素;&lt;/li&gt;
      &lt;li&gt;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;&lt;/li&gt;
      &lt;li&gt;用来保存当前会话信息的sessionStorage，数据在浏览器关闭后自动删除;&lt;/li&gt;
      &lt;li&gt;语意化更好的内容元素，比如 article、footer、header、nav、section;&lt;/li&gt;
      &lt;li&gt;表单控件，calendar、date、time、email、url、search;&lt;/li&gt;
      &lt;li&gt;新的技术webworker, websocket, Geolocation;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;移除的元素：&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;纯表现的元素：basefont，big，center，font, s，strike，tt，u;&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;对可用性产生负面影响的元素：frame，frameset，noframes；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;支持HTML5新标签：
    &lt;ol&gt;
      &lt;li&gt;IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。&lt;/li&gt;
      &lt;li&gt;也可以直接使用成熟的框架、比如html5shim;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8&quot;&gt;8&lt;/h3&gt;

&lt;p&gt;XML,SGML,HTML,XHTML,HTML5&lt;/p&gt;

&lt;p&gt;他们都是ML，都是标记语言（Markup Language），所以不同就是前面的部分了。&lt;/p&gt;

&lt;p&gt;SGML(Standard Generalized Markup Language)，即标准通用标记语言, 是一种古老，复杂的标准&lt;/p&gt;

&lt;p&gt;HTML(HyperText Markup Language)，超文本标记语言，是语法较为松散的、不严格的Web语言，SGML的子集，其中的HTML5已经不是SGML的子集了&lt;/p&gt;

&lt;p&gt;XML（eXtensible Markup Language），可扩展标记语言，主要用于存储数据和结构，可扩展，SGML的子集&lt;/p&gt;

&lt;p&gt;XHTML（eXtensible HyperText Markup Language），可扩展超文本标记语言，基于XML，作用与HTML类似，但语法更严格。所有标签必须闭合，每一个属性都必须使用引号包住。&amp;lt;br&amp;gt;要写成&amp;lt;br /&amp;gt;，不能写为&amp;lt;BR /&amp;gt;（同hr）；使用了&amp;lt;p&amp;gt;之后必须有一个&amp;lt;/p&amp;gt;以结束段落。&lt;/p&gt;

&lt;h3 id=&quot;9&quot;&gt;9&lt;/h3&gt;

&lt;p&gt;HTML语义化&lt;/p&gt;

&lt;p&gt;就是用正确的标签做正确的事情。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;&lt;/li&gt;
  &lt;li&gt;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;&lt;/li&gt;
  &lt;li&gt;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;&lt;/li&gt;
  &lt;li&gt;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;10&quot;&gt;10&lt;/h3&gt;

&lt;p&gt;cookie, loaclStorage, sessionStorage&lt;/p&gt;

&lt;p&gt;cookie: 可设置失效时间，默认是浏览器关闭后，大小4K左右，每次都会携带在HTTP头中，这也是大小限制的原因，如果使用cookie保存过多数据会带来性能问题，主要用于保存密码等信息&lt;/p&gt;

&lt;p&gt;localStorage: 除非主动删除，否则永久保留，一般5M左右，仅在浏览器保存，不参与通信&lt;/p&gt;

&lt;p&gt;sessionStorage: 仅在当前会话下有效，刷新不删除，关闭页面或浏览器清除，一般5M左右，仅在浏览器保存，不参与通信&lt;/p&gt;

&lt;p&gt;另外sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。&lt;/p&gt;

&lt;h3 id=&quot;11&quot;&gt;11&lt;/h3&gt;

&lt;p&gt;浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？&lt;/p&gt;

&lt;p&gt;在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
离线的情况下，浏览器就直接使用离线存储的资源。&lt;/p&gt;

&lt;h3 id=&quot;12&quot;&gt;12&lt;/h3&gt;

&lt;p&gt;iframe缺点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;iframe会阻塞主页面的Onload事件；&lt;/li&gt;
  &lt;li&gt;搜索引擎的检索程序无法解读这种页面，不利于SEO;&lt;/li&gt;
  &lt;li&gt;iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
  动态给iframe添加src属性值，这样可以绕开以上两个问题。&lt;/p&gt;

&lt;h3 id=&quot;13&quot;&gt;13&lt;/h3&gt;

&lt;p&gt;Label的作用是什么？是怎么用的？&lt;/p&gt;

&lt;p&gt;&amp;lt;label&amp;gt; 标签为 input 元素定义标注（标记）。
label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。用for属性绑定id。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;
&amp;lt;label for=&quot;male&quot;&amp;gt;Male&amp;lt;/label&amp;gt;
&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;label for=&quot;female&quot;&amp;gt;Female&amp;lt;/label&amp;gt;
&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;14&quot;&gt;14&lt;/h3&gt;

&lt;p&gt;title与h1的区别、b与strong的区别、i与em的区别？&lt;/p&gt;

&lt;p&gt;title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；&lt;/p&gt;

&lt;p&gt;strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&amp;lt;strong&amp;gt;会重读，而&amp;lt;B&amp;gt;是展示强调内容。&lt;/p&gt;

&lt;p&gt;i内容展示为斜体，em表示强调的文本；&lt;/p&gt;

&lt;p&gt;Physical Style Elements – 自然样式标签&lt;br /&gt;
  b, i, u, s, pre&lt;br /&gt;
  Semantic Style Elements – 语义样式标签&lt;br /&gt;
  strong, em, ins, del, code&lt;br /&gt;
  应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Dec 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/12/06/Html-Note(1)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/12/06/Html-Note(1)/</guid>
        
        <category>Html</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Note(4)</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;前端设计模式&lt;/p&gt;

&lt;h4 id=&quot;单体模式singleton&quot;&gt;单体模式(Singleton)&lt;/h4&gt;

&lt;p&gt;将一批属性和方法组织在一起的对象，用来划分命名空间。其特点：&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;划分命名空间，只暴露一个入口，减少全局变量带来的风险&lt;/li&gt;
  &lt;li&gt;利用分支技术来来封装浏览器之间的差异。&lt;/li&gt;
  &lt;li&gt;可以把代码组织的更为一体，便于阅读和维护。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var singleton = {
    attribute: {},
    method1: function(){},
    method2: function(){}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;单例模式single&quot;&gt;单例模式(Single)&lt;/h4&gt;

&lt;p&gt;单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var single = (function(){
    var unique;

    function getInstance(){　　　　// 如果该实例存在，则直接返回，否则就对其实例化
        if( unique === undefined ){
            unique = new Construct();
        }
        return unique;
    }

    function Construct(){
        // ... 生成单例的构造函数的代码
    }

    return {
        getInstance : getInstance
    }
})();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;工厂模式factory&quot;&gt;工厂模式(Factory)&lt;/h4&gt;

&lt;p&gt;提供一个创建对象的借口，无需指定具体的类，把成员对象的创建工作转交给一个外部对象，&lt;strong&gt;好处在于消除对象之间的耦合(也就是相互影响), 有助于创建模块化的代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单工厂模式&lt;/strong&gt;：使用一个类，通常为单体，来生成实例。典型的实例，xhr工厂。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   var XMLHttpFactory =function(){};　　　　　　//这是一个简单工厂模式
　　XMLHttpFactory.createXMLHttp =function(){
　　　 var XMLHttp = null;
　　　　if (window.XMLHttpRequest){
　　　　　　XMLHttp = new XMLHttpRequest()
　　　 }else if (window.ActiveXObject){
　　　　　　XMLHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
　　　　}
　　return XMLHttp;
　　}
　　//XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。
　　var AjaxHander =function(){
　　　　var XMLHttp = XMLHttpFactory.createXMLHttp();
　　　　...
　　}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;复杂工厂模式&lt;/strong&gt;：先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var XMLHttpFactory =function(){};　     //这是一个抽象工厂模式

XMLHttpFactory.prototype = {
　　//如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类
　　createFactory:function(){
  　　throw new Error('This is an abstract class');
　　}
}

var XHRHandler =function(){}; //定义一个子类

// 子类继承父类原型方法
extend( XHRHandler , XMLHttpFactory );

XHRHandler.prototype =new XMLHttpFactory(); //把超类原型引用传递给子类,实现继承

XHRHandler.prototype.constructor = XHRHandler; //重置子类原型的构造器为子类自身

//重新定义createFactory 方法
XHRHandler.prototype.createFactory =function(){
　　var XMLHttp =null;
　　if (window.XMLHttpRequest){

  　　XMLHttp =new XMLHttpRequest();

　　}else if (window.ActiveXObject){

  　　XMLHttp =new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
　　}

　　return XMLHttp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;应用场景：&lt;/p&gt;

&lt;p&gt;以下几种情景下工厂模式特别有用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象的构建十分复杂&lt;/li&gt;
  &lt;li&gt;需要依赖具体环境创建不同实例&lt;/li&gt;
  &lt;li&gt;处理大量具有相同属性的小对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;可以实现一些相同的方法，这些相同的方法我们可以放在父类中编写代码，那么需要实现具体的业务逻辑，那么可以放在子类中重写该父类的方法，去实现自己的业务逻辑；&lt;/p&gt;

&lt;p&gt;也就是说有两点：　　&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。&lt;/li&gt;
  &lt;li&gt;重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;当工厂增加到一定程度的时候，提升了代码的复杂度，可读性下降。而且没有解决对象的识别问题，即怎么知道一个对象的类型。&lt;/p&gt;

&lt;h4 id=&quot;策略模式strategy&quot;&gt;策略模式(Strategy)&lt;/h4&gt;

&lt;p&gt;策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。&lt;/p&gt;

&lt;p&gt;代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额。&lt;/p&gt;

&lt;p&gt;没有使用策略模式的情况：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Price(personType, price) {
    //vip 5 折
    if (personType == 'vip') {
        return price * 0.5;
    } 
    else if (personType == 'old'){ //老客户 3 折
        return price * 0.3;
    } else {
        return price; //其他都全价
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;不足之处：不好的地方，当我有其他方面的折扣时，又或者我活动的折扣时经常变化的，这样就要不断的修改if..else里面的条件了。而且也违背了设计模式的一个原则：&lt;strong&gt;对修改关闭，对扩展开放的原则&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;使用策略模式之后：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 对于vip客户
function vipCustomer() {
    this.discount = 0.5;
}
 
vipCustomer.prototype.getPrice = function(price) {
　　return price * this.discount;
}
// 对于老客户
function oldCustomer() {
    this.discount = 0.3;
}
 
oldCustomer.prototype.getPrice = function(price) {
    return price * this.discount;
}
// 对于普通客户
function normalCustomer() {
    this.discount = 1;
}
 
normalCustomer.prototype.getPrice = function(price) {
    return price ;
}

// 上下文，对于客户端的使用
function Context() {
    this.name = '';
    this.strategy = null;
    this.price = 0;
}
 
Context.prototype.set = function(name, strategy, price) {
    this.name = name;
    this.strategy = strategy;
    this.price = price;
}
Context.prototype.getResult = function() {
    console.log(this.name + ' 的结账价为: ' + this.strategy.getPrice(this.price));
}

var context = new Context();
var vip = new vipCustomer();
context.set ('vip客户', vip, 200);
context.getResult();   // vip客户 的结账价为: 100

var old = new oldCustomer();
context.set ('老客户', old, 200);
context.getResult();  // 老客户 的结账价为: 60

var Price = new normalCustomer();
context.set ('普通客户', Price, 200);
context.getResult();  // 普通客户 的结账价为: 200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;装饰者模式decrator&quot;&gt;装饰者模式（decrator）&lt;/h4&gt;

&lt;p&gt;动态地给一个对象添加一些新的方法。就扩展功能而言，它比生成子类方式更为灵活。装饰者的运作过程是透明的，这就是说你可以用它包装其他对象，然后继续按之前使用那么对象的方法来使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var myText= {};
myText.Decorations={};
myText.Core=function(myString){
    this.show =function(){return myString;}
}
//第一次装饰，string后加？
myText.Decorations.addQuestuibMark =function(myString){
    this.show =function(){return myString.show()+'?';};
}
//第二次装饰，添加标签
myText.Decorations.makeItalic =function(myString){
    this.show =function(){return'&amp;lt;li&amp;gt;'+myString.show()+'&amp;lt;/li&amp;gt;'};
}
//得到myText.Core的实例
var theString =new myText.Core('this is a sample test String');
alert(theString.show());　　//output 'this is a sample test String'

//得到？装饰后的String
theString =new myText.Decorations.addQuestuibMark(theString);
alert(theString.show());　　//output 'this is a sample test String?'

//得到标签装饰后的String
theString =new myText.Decorations.makeItalic (theString);
alert(theString.show());　　//output '&amp;lt;li&amp;gt;this is a sample test String&amp;lt;/li&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从这个示例中可以看出，我们的目的是为了得到装饰过得String，这一切都可以不用事先知道组件对象的接口，也就是说我们只需要调用myString.show()，而其中具体的实现不用关心，甚至可以动态的实现。&lt;/p&gt;

&lt;p&gt;在为现有对象增添特性这方面，装饰者模式有极大的灵活性。如果需要为类增加特性或者方法，而从该类派生子类的解决办法并不实际的话，就应该使用装饰者模式。派生子类之所以会不实际最常见的原因是需要添加的特性或方法的数量要求使用大量子类。&lt;/p&gt;

&lt;h4 id=&quot;适配器模式adapter&quot;&gt;适配器模式（Adapter）&lt;/h4&gt;

&lt;p&gt;将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作，使用这种模式的对象又叫包装器，因为他们是在用一个新的接口包装另一个对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//一个参数为两个字符串的接口函数
var interface = function(str1, str2){
    ...
}
//现在我们想使用上面接口函数，但是参数是一个对象
var test = {
    str1 : '1',
    str2 : '2'
}
//适配器函数
var adapterMethod = function(obj){
    return interface(obj.str1, obj.str2);
}
//调用
adapterMethod(test);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;观察者模式observer&quot;&gt;观察者模式（Observer）&lt;/h4&gt;

&lt;p&gt;定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。典型的是事件监听器绑定。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id='test'&amp;gt;test&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
var fn1 = function(){
    ...
}
var fn2 = function(){
    ...
}
var test = document.getElementsById('test');
//绑定两个监听click事件
test.addElementListener('click', fn1, false);
test.addELementListener('click', fn2, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;门面模式facede&quot;&gt;门面模式（facede）&lt;/h4&gt;

&lt;p&gt;子系统中的一组接口提供一个一致的界面，门面模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。实际上就是把一组工具函数包装在一个对象里，对外的门面就是这个对象，&lt;strong&gt;门面模式是几乎所有JavaScript库的核心原则&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;优雅降级和渐进增强&lt;/p&gt;

&lt;p&gt;优雅降级：Web站点在所有新式浏览器中都能正常工作的前提下，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：border-shadow&lt;/p&gt;

&lt;p&gt;渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；&lt;/p&gt;

&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;

&lt;p&gt;Node的优缺点&lt;/p&gt;

&lt;p&gt;（优点) 因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
    因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
    此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，
    因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。&lt;/p&gt;

&lt;p&gt;（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，
    而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。&lt;/p&gt;

&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;

&lt;p&gt;前端性能优化的办法&lt;/p&gt;

&lt;p&gt;（1）减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。&lt;/p&gt;

&lt;p&gt;（2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数&lt;/p&gt;

&lt;p&gt;（3）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。&lt;/p&gt;

&lt;p&gt;（4）当需要设置的样式很多时设置className而不是直接操作style。&lt;/p&gt;

&lt;p&gt;（5）少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。&lt;/p&gt;

&lt;p&gt;（6）避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。&lt;/p&gt;

&lt;p&gt;（7）图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。&lt;/p&gt;

&lt;p&gt;（8）避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
    对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。&lt;/p&gt;

&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;

&lt;p&gt;http状态码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200  OK         正常返回信息
201  Created    请求成功并且服务器创建了新的资源
202  Accepted   服务器已接受请求，但尚未处理
301  Moved Permanently  请求的网页已永久移动到新位置。
302  Found       临时性重定向。
303  See Other   临时性重定向，且总是使用 GET 请求新的 URI。
304  Not Modified 自从上次请求后，请求的网页未修改过。
400  Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401  Unauthorized 请求未授权。
403  Forbidden   禁止访问。
404  Not Found   找不到如何与 URI 相匹配的资源。
500  Internal Server Error  最常见的服务器端错误。
503  Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;

&lt;p&gt;一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;再输入url的时候，浏览器可能会做一些预处理，比如 Chrome 会根据历史统计来预估所输入字符对应的网站，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「www.baidu.com 」，因此就会在输入回车前就马上开始建立 TCP 链接甚至渲染了，还有很多其它很多优化策略&lt;/li&gt;
  &lt;li&gt;浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;&lt;/li&gt;
  &lt;li&gt;浏览器内核中会先查看缓存，然后调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;&lt;/li&gt;
  &lt;li&gt;进行DNS解析，使用UDP协议获取网址的IP地址;&lt;/li&gt;
  &lt;li&gt;设置 UA 等信息发出第二个GET请求，进行HTTP协议会话，客户端发送报头(请求报头);&lt;/li&gt;
  &lt;li&gt;进过运营商路由，主干网传输，进入到相应服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;&lt;/li&gt;
  &lt;li&gt;进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的处理过程;&lt;/li&gt;
  &lt;li&gt;处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回http状态码304，表示网页未修改过;&lt;/li&gt;
  &lt;li&gt;浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;&lt;/li&gt;
  &lt;li&gt;文档树建立，根据标记请求所需指定css、js等文件,同时设置cookie;&lt;/li&gt;
  &lt;li&gt;浏览器内核开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成，呈现给用户。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;7&quot;&gt;7&lt;/h3&gt;

&lt;p&gt;对称/非对称加密，公钥和私钥&lt;/p&gt;

&lt;p&gt;基本概念:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对称加密, 最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非对称加密， 非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;密钥对，在非对称加密技术中，有两种密钥，分为私钥和公钥，私钥是密钥对所有者持有，不可公布，公钥是密钥对持有者公布给他人的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;摘要，对需要传输的文本，做一个HASH计算，一般采用SHA1，SHA2来获得。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;签名，使用私钥对需要传输的文本的摘要进行加密，得到的密文即被称为该次传输过程的签名。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;签名验证，数据接收端，拿到传输文本，但是需要确认该文本是否就是发送发出的内容，中途是否曾经被篡改。因此拿自己持有的公钥对签名进行解密（密钥对中的一种密钥加密的数据必定能使用另一种密钥解密。），得到了文本的摘要，然后使用与发送方同样的HASH算法计算摘要值，再与解密得到的摘要做对比，发现二者完全一致，则说明文本没有被篡改过。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;证书中心（certificate authority，简称CA), CA用自己的私钥，对发送者公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate），发送时连同签名一起发送&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。而非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。&lt;/p&gt;

&lt;p&gt;以Alice和银行之间的通信为例，这同时也是https协议的简略过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Alice向Bank请求公钥&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bank网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给Alice的浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Alice的浏览器获得证书后验证合法性，客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表，客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若证书合法，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密，这就是对称加密的秘钥。接下来会进行握手验证，使用约定好的HASH算法加密一段握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的对称加密的秘钥（使用公钥加密过的）+ 加密的握手消息发送给Bank。 若不合法则发出警告。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bank使用私钥解密得到对称秘钥，使用秘钥解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 然后使用密码加密一段握手消息，发送给浏览器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，Alice和Bank使用对称秘钥互相传输数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/lrun1124.github.io/img/jsbase4/Alice&amp;amp;Bank.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTPS一般使用的加密与HASH算法如下：&lt;/p&gt;

&lt;p&gt;非对称加密算法：RSA，DSA/DSS&lt;/p&gt;

&lt;p&gt;对称加密算法：AES，RC4，3DES&lt;/p&gt;

&lt;p&gt;HASH算法：MD5，SHA1，SHA256&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Dec 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/12/04/JaveScript-Note(4)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/12/04/JaveScript-Note(4)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Note(3)</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;同步与异步&lt;/p&gt;

&lt;p&gt;同步的概念是来自OS中同步的概念：不同的进程为了完成某项任务在执行先后顺序上进行协作，通过唤醒、阻塞等方式调节。&lt;/p&gt;

&lt;p&gt;对于Web而言：&lt;br /&gt;
同步: 访问服务器，服务器回应，页面刷新，用户操作，整个过程是串行的方式进行的，影响用户操作&lt;br /&gt;
异步: 访问服务器，用户继续操作，服务器回应，页面更新，用户操作，整个过程不发生整页刷新，不影响用户操作&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;跨域问题&lt;/p&gt;

&lt;h4 id=&quot;同源策略&quot;&gt;同源策略&lt;/h4&gt;

&lt;p&gt;同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。&lt;/p&gt;

&lt;h4 id=&quot;jsonp&quot;&gt;JSONP&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;由于同源政策的存在，Ajax直接请求普通文件存在跨域无权限访问的问题，无论是静态页面、动态网页、web服务，只要是跨域请求，一律不准；另一方面，通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，这些拥有”src”这个属性的标签都拥有跨域的能力，比如&amp;lt;script&amp;gt;、&amp;lt;img&amp;gt;、&amp;lt;iframe&amp;gt;等标签。&lt;/li&gt;
  &lt;li&gt;JSONP正是利用这一点，web客户端通过与调用脚本一模一样的方式来调用跨域服务器上的资源，服务器端则动态生成JSON，把客户端需要的数据装入进去。&lt;/li&gt;
  &lt;li&gt;其缺点是只能实现get一种请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;script&amp;gt;
 //原生实现
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参并指定回调执行函数为onBack
    script.src = 'http://www.domain2.com:8080/login?user=admin&amp;amp;callback=onBack';
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
 &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;postmessage&quot;&gt;postMessage&lt;/h4&gt;

&lt;p&gt;postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;页面和其打开的新窗口的数据传递&lt;/li&gt;
  &lt;li&gt;多窗口之间消息传递&lt;/li&gt;
  &lt;li&gt;页面与嵌套的iframe消息传递&lt;/li&gt;
  &lt;li&gt;上面三个场景的跨域数据传递&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用法：postMessage(data,origin)方法接受两个参数&lt;/p&gt;

&lt;p&gt;data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。&lt;br /&gt;
origin： 协议+主机+端口号，也可以设置为”*“，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/”。&lt;/p&gt;

&lt;p&gt;1.）a.html：(http://www.domain1.com/a.html)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script&amp;gt;       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };

    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---&amp;gt; ' + e.data);
    }, false);
&amp;lt;/script
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.）b.html：(http://www.domain2.com/b.html)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---&amp;gt; ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;corscross-orign-resource-share跨域资源共享&quot;&gt;CORS(Cross orign resource share)跨域资源共享&lt;/h4&gt;

&lt;p&gt;服务器端设置Access-Control-Allow-Origin,前端无须设置&lt;/p&gt;

&lt;p&gt;“*”号表示允许任何域向我们的服务端提交请求：Access-Control-Allow-Origin：*&lt;/p&gt;

&lt;p&gt;也可以设置指定的域名，如域名 http://www.test2.com ，那么就允许来自这个域名的请求：Access-Control-Allow-Origin：http://www.test2.com&lt;/p&gt;

&lt;p&gt;若要带cookie请求：前后端都需要设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200) {
        alert(xhr.responseText);
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;

&lt;p&gt;页面编码和被请求的资源编码如果不一致如何处理？&lt;/p&gt;

&lt;p&gt;设置charset&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;http://www.xxx.com/test.js&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;//todo&lt;/p&gt;

&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;

&lt;p&gt;前端模块化加载&lt;/p&gt;

&lt;p&gt;知识点1：AMD(Asynchronous Module Definition)/CMD(Common Module Definition)/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs.&lt;/p&gt;

&lt;p&gt;知识点2：CommonJs主要针对服务端，AMD/CMD主要针对浏览器端，所以最容易混淆的是AMD/CMD。（顺便提一下，针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行。这里如果有其他后端语言，如java，经验的‘玩家’应该更容易理解。而浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好。）&lt;/p&gt;

&lt;p&gt;知识点3 : AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。&lt;/p&gt;

&lt;p&gt;知识点4：AMD/CMD的优缺点.一个的优点就是另一个的缺点， 可以对照浏览。&lt;/p&gt;

&lt;p&gt;AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。&lt;br /&gt;
AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。&lt;/p&gt;

&lt;p&gt;CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。&lt;br /&gt;
CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。&lt;/p&gt;

&lt;p&gt;知识点5：如何使用？CommonJs的话，因为nodeJs就是它的实现，所以使用node就行，也不用引入其他包。AMD则是通过&amp;lt;script&amp;gt;标签引入RequireJs，CMD则是引入SeaJs。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // CMD
 define(function(require, exports, module) {
     var a = require('./a')
     a.doSomething()
     // 此处略去 100 行
     var b = require('./b') // 依赖可以就近书写
     b.doSomething()
     // ...
 })

 // AMD 默认推荐
 define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
     a.doSomething()
     // 此处略去 100 行
     b.doSomething()
     // ...
 })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;

&lt;p&gt;DOM操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//创建
createElement() //创建元素
createDocumentFragment()  //创建DOM片段
createTextNode() //创建文本节点

//操作
appendChild() //添加
removeChild() //删除
replaceChild() //替换
insertbefore() //在已有节点前插入新节点

//查找
getElementsById()
getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
getElementsByTag()
getElementsByClass()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;

&lt;p&gt;call和apply&lt;/p&gt;

&lt;p&gt;foo.call(this, arg1,arg2,arg3) == foo.apply(this, arguments)==this.foo(arg1, arg2, arg3)&lt;/p&gt;

&lt;h3 id=&quot;7&quot;&gt;7&lt;/h3&gt;

&lt;p&gt;内存泄漏&lt;/p&gt;

&lt;p&gt;内存泄漏时指一块被分配的内存既不能使用也不能回收。在JavaScipt出现主要有两种情况:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;循环引用。含有DOM对象的循环引用将导致大部分当前主流浏览器内存泄露。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//a,b循环引用
var a = new Object;
var b = new Object;
a.r = b;
b.r = a;

//a循环引用自己
var a = new Object;
a.r = a;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;闭包。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;闭包可以导致内存泄漏是因为内部方法保持一个对外部方法变量的引用，所以尽管方法返回了内部方法还可以继续访问在外部方法中定义的私有变量，所以这些变量被一直保存在内存中。&lt;/p&gt;

&lt;h3 id=&quot;8&quot;&gt;8&lt;/h3&gt;

&lt;p&gt;如何判断当前脚本运行在浏览器还是node环境中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this === window ? 'browser' : 'node'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;9&quot;&gt;9&lt;/h3&gt;

&lt;p&gt;把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？&lt;/p&gt;

&lt;p&gt;放在body的封闭之前，将会阻塞其他资源的加载，放在body封闭之后，不会影响body内元素的加载&lt;/p&gt;

&lt;h3 id=&quot;10&quot;&gt;10&lt;/h3&gt;

&lt;p&gt;给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？&lt;/p&gt;

&lt;p&gt;绑定几个事件就执行几次，执行优先级:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;父元素的捕获事件&lt;/li&gt;
  &lt;li&gt;目标元素的顺序事件，无视捕获还是冒泡&lt;/li&gt;
  &lt;li&gt;父元素的冒泡事件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class='d1'&amp;gt;
    &amp;lt;div class='d2'&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script type='text/javascript'&amp;gt;
var d1 = document.getElementsByClass('d1');
var d2 = document.getElementsByClass('d2');
     
//父级绑定click事件冒泡
d1.addEventListener('click', function(){ console.log('parent bubble') }, false);

//子级绑定click事件冒泡
d2.addEventListener('click', function(){ console.log('child bubble') }, false);

//子级绑定click事件捕获
d2.addEventListener('click', function(){ console.log('child capture') }, true);

//父级绑定click事件捕获
d1.addEventListener('click', function(){ console.log('parent capture') }, true);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;console:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;parent capture
child bubble
child capture
parent bubble
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;11&quot;&gt;11&lt;/h3&gt;

&lt;p&gt;==, ===, Object.is()区别&lt;/p&gt;

&lt;p&gt;==会进行类型转换，===不会，Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.&lt;/p&gt;

&lt;h3 id=&quot;12&quot;&gt;12&lt;/h3&gt;

&lt;p&gt;前端设计模式&lt;/p&gt;

&lt;h4 id=&quot;单体模式&quot;&gt;单体模式&lt;/h4&gt;

&lt;p&gt;将一批属性和方法组织在一起的对象，用来划分命名空间。其特点：&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;划分命名空间，只暴露一个入口，减少全局变量带来的风险&lt;/li&gt;
  &lt;li&gt;利用分支技术来来封装浏览器之间的差异。&lt;/li&gt;
  &lt;li&gt;可以把代码组织的更为一体，便于阅读和维护。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var singleton = {
    attribute: {},
    method1: function(){},
    method2: function(){}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;单例模式&quot;&gt;单例模式&lt;/h4&gt;

&lt;p&gt;单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var single = (function(){
    var unique;

    function getInstance(){　　　　// 如果该实例存在，则直接返回，否则就对其实例化
        if( unique === undefined ){
            unique = new Construct();
        }
        return unique;
    }

    function Construct(){
        // ... 生成单例的构造函数的代码
    }

    return {
        getInstance : getInstance
    }
})();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;工厂模式&quot;&gt;工厂模式&lt;/h4&gt;

&lt;p&gt;提供一个创建对象的借口，无需指定具体的类，把成员对象的创建工作转交给一个外部对象，&lt;strong&gt;好处在于消除对象之间的耦合(也就是相互影响), 有助于创建模块化的代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单工厂模式&lt;/strong&gt;：使用一个类，通常为单体，来生成实例。典型的实例，xhr工厂。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   var XMLHttpFactory =function(){};　　　　　　//这是一个简单工厂模式
　　XMLHttpFactory.createXMLHttp =function(){
　　　 var XMLHttp = null;
　　　　if (window.XMLHttpRequest){
　　　　　　XMLHttp = new XMLHttpRequest()
　　　 }else if (window.ActiveXObject){
　　　　　　XMLHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
　　　　}
　　return XMLHttp;
　　}
　　//XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。
　　var AjaxHander =function(){
　　　　var XMLHttp = XMLHttpFactory.createXMLHttp();
　　　　...
　　}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;复杂工厂模式&lt;/strong&gt;：先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var XMLHttpFactory =function(){};　     //这是一个抽象工厂模式

XMLHttpFactory.prototype = {
　　//如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类
　　createFactory:function(){
  　　throw new Error('This is an abstract class');
　　}
}

var XHRHandler =function(){}; //定义一个子类

// 子类继承父类原型方法
extend( XHRHandler , XMLHttpFactory );

XHRHandler.prototype =new XMLHttpFactory(); //把超类原型引用传递给子类,实现继承

XHRHandler.prototype.constructor = XHRHandler; //重置子类原型的构造器为子类自身

//重新定义createFactory 方法
XHRHandler.prototype.createFactory =function(){
　　var XMLHttp =null;
　　if (window.XMLHttpRequest){

  　　XMLHttp =new XMLHttpRequest();

　　}else if (window.ActiveXObject){

  　　XMLHttp =new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
　　}

　　return XMLHttp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;应用场景：&lt;/p&gt;

&lt;p&gt;以下几种情景下工厂模式特别有用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象的构建十分复杂&lt;/li&gt;
  &lt;li&gt;需要依赖具体环境创建不同实例&lt;/li&gt;
  &lt;li&gt;处理大量具有相同属性的小对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;可以实现一些相同的方法，这些相同的方法我们可以放在父类中编写代码，那么需要实现具体的业务逻辑，那么可以放在子类中重写该父类的方法，去实现自己的业务逻辑；&lt;/p&gt;

&lt;p&gt;也就是说有两点：　　&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。&lt;/li&gt;
  &lt;li&gt;重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;当工厂增加到一定程度的时候，提升了代码的复杂度，可读性下降。而且没有解决对象的识别问题，即怎么知道一个对象的类型。&lt;/p&gt;

&lt;h4 id=&quot;策略模式&quot;&gt;策略模式&lt;/h4&gt;

&lt;p&gt;策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。&lt;/p&gt;

&lt;p&gt;代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额。&lt;/p&gt;

&lt;p&gt;没有使用策略模式的情况：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Price(personType, price) {
    //vip 5 折
    if (personType == 'vip') {
        return price * 0.5;
    } 
    else if (personType == 'old'){ //老客户 3 折
        return price * 0.3;
    } else {
        return price; //其他都全价
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;不足之处：不好的地方，当我有其他方面的折扣时，又或者我活动的折扣时经常变化的，这样就要不断的修改if..else里面的条件了。而且也违背了设计模式的一个原则：&lt;strong&gt;对修改关闭，对扩展开放的原则&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;使用策略模式之后：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 对于vip客户
function vipPrice() {
    this.discount = 0.5;
}
 
vipPrice.prototype.getPrice = function(price) {
　　return price * this.discount;
}
// 对于老客户
function oldPrice() {
    this.discount = 0.3;
}
 
oldPrice.prototype.getPrice = function(price) {
    return price * this.discount;
}
// 对于普通客户
function Price() {
    this.discount = 1;
}
 
Price.prototype.getPrice = function(price) {
    return price ;
}

// 上下文，对于客户端的使用
function Context() {
    this.name = '';
    this.strategy = null;
    this.price = 0;
}
 
Context.prototype.set = function(name, strategy, price) {
    this.name = name;
    this.strategy = strategy;
    this.price = price;
}
Context.prototype.getResult = function() {
    console.log(this.name + ' 的结账价为: ' + this.strategy.getPrice(this.price));
}

var context = new Context();
var vip = new vipPrice();
context.set ('vip客户', vip, 200);
context.getResult();   // vip客户 的结账价为: 100

var old = new oldPrice();
context.set ('老客户', old, 200);
context.getResult();  // 老客户 的结账价为: 60

var Price = new Price();
context.set ('普通客户', Price, 200);
context.getResult();  // 普通客户 的结账价为: 200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 29 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/29/JavaScript-Note(3)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/29/JavaScript-Note(3)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Note(2)</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;This的理解&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;this总是指向函数的直接调用者（而非简洁调用者）,即此次调用的所有者&lt;/li&gt;
  &lt;li&gt;如果有new对象，this指向new出来的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;Eval&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Eval将传入的字符串当做JS代码执行, 应避免在不必要的情况下使用
    &lt;ul&gt;
      &lt;li&gt;运行Eval存在风险，有可能运行的是恶意代码&lt;/li&gt;
      &lt;li&gt;运行效率差，因为会调用JS解析器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;

&lt;p&gt;window对象和document对象&lt;/p&gt;

&lt;p&gt;window对象是浏览器打开的窗口，顶层对象，document是window对象的一个属性，HTML文档对象的一个&lt;strong&gt;只读引用&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;

&lt;p&gt;IE和firefox事件机制&lt;/p&gt;

&lt;p&gt;IE是事件冒泡，firefox同时支持事件冒泡和捕获&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;时间捕获: 越高层的元素越早接收到事件，由上到下&lt;/li&gt;
  &lt;li&gt;事件冒泡: 越低层的元素越早接收到时间，由下到上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组织冒泡事件的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;xxx.click = function(e){
	e.stopPropagation();
	e.cancelBubble = true;//旧IE需要
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;

&lt;p&gt;new的过程&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建空对象；
    &lt;ul&gt;
      &lt;li&gt;var obj = {};&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将创建出对象的原型链引用指向所要构造函数的原型；
    &lt;ul&gt;
      &lt;li&gt;obj.__proto__ = ClassA.prototype;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;调用构造函数，this指向新实例对象：
    &lt;ul&gt;
      &lt;li&gt;ClassA.call(obj);　　//{}.构造函数();&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将初始化完毕的新对象地址，保存到等号左边的变量中&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;

&lt;p&gt;JS中不会查找原型的函数&lt;/p&gt;

&lt;p&gt;hasOwnProperty判断对象中是否有指定名称的属性，object.hasOwnProperty(proName)，proName是属性名称的&lt;strong&gt;字符串值&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;7&quot;&gt;7&lt;/h3&gt;

&lt;p&gt;JSON的了解&lt;/p&gt;

&lt;p&gt;JSON（JavaScript Object Notation）是一种&lt;strong&gt;轻量级的数据交换格式&lt;/strong&gt;，是基于JavaScript的一个子集，具有&lt;strong&gt;数据格式简单，易于读写且占用带宽小&lt;/strong&gt;的优点。&lt;/p&gt;

&lt;p&gt;字符串转对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;JSON.parse(str);
str.parseJSON(str);
eval('(' + str + ')')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象转字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;JSON.stringify(obj);
obj.toJSONString(str);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8&quot;&gt;8&lt;/h3&gt;

&lt;p&gt;Ajax&lt;/p&gt;

&lt;p&gt;Asynchronous JavaScript and Xml, 异步传输+JS+xml，异步的含义是在向服务器发送请求后，不必等待响应，可以先做其他的事，等相应返回可以根据设定的callback函数进行操作，于此同时，网页不会发生整页刷新，提高了效率和用户体验。&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建XMLHttpRequest对象&lt;/li&gt;
  &lt;li&gt;设置响应HTTP请求状态变化的函数&lt;/li&gt;
  &lt;li&gt;指定该对象的的方法、URL及验证信息&lt;/li&gt;
  &lt;li&gt;发送HTTP请求&lt;/li&gt;
  &lt;li&gt;获取异步调用返回的数据&lt;/li&gt;
  &lt;li&gt;使用JavaScript和DOM实现局部刷新&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button id=&quot;ajaxButton&quot; type =&quot;button&quot;&amp;gt;Make Ajax request&amp;lt;/button&amp;gt;

&amp;lt;script&amp;gt;
var httpRequest;
document.getElementbyId('ajaxButton').addEventListener(&quot;click&quot;, sendRequest);

function sendRequest(){
	httpRequest = new XMLHttpRequest(); //1

	if(httpRequest){
		alert('Cannot creat XMLHttpRequest');
		return;
	}

	httpRequest.onreadystatechange = stateFunction;//2
	httpRequest.open('GET', 'test.html');//3
	httpRequest.send();//4
}

function stateFunction(){
	if(httpRequest.readyState === XMLHttpRequet.Done){
		if(httpRequest.state === 200){
			alert(httpRequest.responseText);//5
			//... 6
		}
		else{
			alert('The request has some problem');
		}
	}
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;9&quot;&gt;9&lt;/h3&gt;

&lt;p&gt;JS延迟加载方式&lt;/p&gt;

&lt;p&gt;JS延迟加载就是在页面加载完成后再加载JS文件，有助于提高页面加载速度，提高用户体验。&lt;/p&gt;

&lt;h4 id=&quot;使用defer或async属性&quot;&gt;使用defer或async属性&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;test1.js&quot; defer=&quot;defer&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;test2.js&quot; async&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;只适用于外部脚本，缺点是不能保证脚本会按顺序执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;动态dom操作&quot;&gt;动态DOM操作&lt;/h4&gt;

&lt;p&gt;即利用动态DOM操作按需插入JS文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//延迟1000ms加载new.js
window.onload = function(){
	setTimeout(function(){
		var head = document.getEßlementByTagName('head')[0];
		var js = document.createElement('Script');
		js.type = 'text/javascript';
		js.src = 'new.js';
		head.appendChlid(js); 
	},1000);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;分组最后加载js&quot;&gt;分组最后加载JS&lt;/h4&gt;

&lt;p&gt;JS的引入如果放在head中，则页面加载前就会JS就会被加载，如果放在body中，则会按顺序加载，所以可以将JS分组，将加载过程中不需要的JS放在页面的底部，&amp;lt;/body&amp;gt;标签之前，然而这种方法偶尔会收到Google页面速度测试工具的“延迟加载javascript”警告，Google提供了一套推荐方案：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//这些代码应被放置在&amp;lt;/body&amp;gt;标签前(接近HTML文件底部)
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    function downloadJSAtOnload() {
        var element = document.createElement(&quot;script&quot;);
        element.src = &quot;defer.js&quot;;
        document.body.appendChild(element);
    }
    if (window.addEventListener)
        window.addEventListener(&quot;load&quot;, downloadJSAtOnload, false);
    else if (window.attachEvent)
        window.attachEvent(&quot;onload&quot;, downloadJSAtOnload);
    else window.onload = downloadJSAtOnload;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码意思是等到整个文档加载完后，再加载外部文件“defer.js”。&lt;/p&gt;

&lt;p&gt;使用此段代码的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;复制上面代码；&lt;/li&gt;
  &lt;li&gt;粘贴代码放置在&amp;lt;/body&amp;gt;标签前 (靠近HTML文件底部)；&lt;/li&gt;
  &lt;li&gt;修改“defer.js”为外部JS文件名；&lt;/li&gt;
  &lt;li&gt;确保文件路径是正确的。例如：如果仅输入“defer.js”，那么“defer.js”文件一定与HTML文件在同一文件夹下。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;注意：这段代码直到文档加载完才会加载指定的外部js文件。因此，不应该把那些页面正常加载需要依赖的javascript代码放在这里。而应该将JavaScript代码分成两组。&lt;strong&gt;一组是因页面需要而立即加载的javascript代码，另外一组是在页面加载后进行操作的javascript代码(例如添加click事件或其他东西)&lt;/strong&gt;。这些需等到页面加载后再执行的JavaScript代码，应放在一个外部文件，然后再引进来。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;10&quot;&gt;10&lt;/h3&gt;

&lt;p&gt;Ajax缓存问题&lt;/p&gt;

&lt;p&gt;Ajax能提高页面载入的速度主要的原因是通过ajax减少了重复数据的载入，也就是说在载入数据的同时将数据缓存到内存中，一旦数据被加载其中，只要我们没有刷新页面，这些数据就会一直被缓存在内存中，当我们提交的URL与历史的URL一致时，就不需要提交给服务器，也就是不需要从服务器上面去获取数据，虽然这样降低了服务器的负载提高了用户的体验，但是我们不能获取最新的数据。为了保证我们读取的信息都是最新的，我们就需要禁止缓存功能。&lt;/p&gt;

&lt;p&gt;解决方案有如下几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。&lt;/li&gt;
  &lt;li&gt;在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。&lt;/li&gt;
  &lt;li&gt;在URL后面加上一个随机数： “fresh=” + Math.random();。&lt;/li&gt;
  &lt;li&gt;在URL后面加上时间搓：”nowtime=” + new Date().getTime();。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 24 Nov 2017 03:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/24/JavaScript-Note(2)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/24/JavaScript-Note(2)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Practice</title>
        <description>&lt;h2 id=&quot;1&quot;&gt;1&lt;/h2&gt;

&lt;p&gt;如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;//先找到'.'的位置或末尾，依次向前拼接直到头部
function transfer(num){
	let str = num + '';
	let i = (str.indexOf('.') &amp;gt; 0 ? str.indexOf('.') : str.length) - 3;
	for(; i&amp;gt;0; i-=3){
		str = str.substring(0, i) + ',' + str.substring(i);
	}
	return str;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2&quot;&gt;2&lt;/h2&gt;

&lt;p&gt;数组随机排列&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法1:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;//Random位置插入新数组，删除原数组内元素
function arrayRandom(arr){
	let res = [],
		index;
	while(arr.length &amp;gt; 0){
		index = parseInt(Math.random() * arr.length);
		res.push(arr[index]);
		arr.splice(index,1)
	}
	return res;
}
//test
let arr = [1,2,3,4,5,6,7,8,9,10];
console.log(arrayRandom(arr));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;方法2:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;//利用Array.prototype.sort的compare function
function arrayRandom(arr){
	return arr.sort(function(){
		return Math.random() - 0.5;
		})
}
//test
let arr = [1,2,3,4,5,6,7,8,9,10];
console.log(arrayRandom(arr));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;3&quot;&gt;3&lt;/h2&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript-Pritice/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript-Pritice/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Note(1)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Step 1. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;转前端工作一年多后对JS的一些基础仍然存在盲区，记录一些note查漏补缺&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;js基本数据类型&quot;&gt;JS基本数据类型&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Boolean, null, undefined, String, Number&lt;/li&gt;
  &lt;li&gt;ES 2015 新增 : Symbol
    &lt;ul&gt;
      &lt;li&gt;独一无二的变量，由于对象中的方法属性可能在传递分享时被不小心修改或覆盖，用Symbol可以保证唯一性。let s = Symbol();&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;储存结构
    &lt;ul&gt;
      &lt;li&gt;基本(原始)数据类型在栈(stack)中存储，空间较小，大小固定，会被频繁调用；&lt;/li&gt;
      &lt;li&gt;引用数据类型大小不固定，放在堆中存储&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/jsbase/database.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;js内置对象&quot;&gt;JS内置对象&lt;/h3&gt;

&lt;p&gt;Object对象：所有对象的父对象，原型链最上层
数据封装对象：Array, Boolean, String, Number, Object
其他： Math, Date, RegExp, Error, Function&lt;/p&gt;

&lt;h3 id=&quot;null-undefined区别&quot;&gt;null, undefined区别&lt;/h3&gt;

&lt;p&gt;null表示一个对象没有值，一般是程序员显示声明，Js不会自己设置为null，typeof(null)为Object&lt;/p&gt;

&lt;p&gt;undefined表示一个变量声明了，但还没有初始化， typeof(undefined)为undefined&lt;/p&gt;

&lt;p&gt;null === undefined 为true, null == undefined为false，目前的JS环境中，它们的差别很小，同时存在是因为历史原因，Js初期的设计参考了C等语言，在C中，null可以自动转型为0，由于JS的设计者Brendan Eich认为‘无’的概念最好不是一个对象，并且JS早期缺乏错误处理机制，null自动转型为0可能会造成一些不被察觉的错误，所以设计了undefined&lt;/p&gt;

&lt;h3 id=&quot;js原型原型链&quot;&gt;JS原型，原型链&lt;/h3&gt;

&lt;p&gt;原型: JavaScript借鉴了面向对象语言‘一切皆是对象’的思想，对于每一个对象都存在一个prototype对象，也就是原型，prototype属性默认有一个constructor属性指向对象本身。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/jsbase/prototype.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以内置对象Object为例，其prototype对象如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/jsbase/objectPrototype.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到其中包括了很多常用内置方法，在其他object调用这些方法的时候就是通过原型链生效的&lt;/p&gt;

&lt;p&gt;原型链: JS的继承是通过原型链实现的。当JS的对象需要某个属性的时候，首先会从当前对象的属性中去找，找不到就会到原型prototype中去找，还是找不到就会沿着原型链向上寻找，直到找到Object.prototype，如果最终找不到，则返回null&lt;/p&gt;

&lt;h3 id=&quot;作用域&quot;&gt;作用域&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;全局作用域
    &lt;ul&gt;
      &lt;li&gt;最外层定义的变量&lt;/li&gt;
      &lt;li&gt;未定义直接赋值的变量&lt;/li&gt;
      &lt;li&gt;顶层对象windows下的变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;局部作用域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JS的作用域和Java,C++之类语言最大的区别就在于它的函数作用域，对于一些熟悉Java,C++语言的人，会造成一些难以理解的结果。可以通过几个例子来看一下：&lt;/p&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i = 'out';
var test = function(){
	console.log(i);
	var i = 'in';
	console.log(i);
}
test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里运行结果是&lt;br /&gt;
undefined&lt;br /&gt;
in&lt;br /&gt;
而不是&lt;br /&gt;
out&lt;br /&gt;in&lt;/p&gt;

&lt;p&gt;code2：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i = 'out';
if(true){
	var i = 'in'
	console.log(i);
}
console.log(i);

test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里运行结果是&lt;br /&gt;
in&lt;br /&gt;
in&lt;br /&gt;
而不是&lt;br /&gt;
in&lt;br /&gt;
out&lt;/p&gt;

&lt;p&gt;造成结果的原因都是因为JS的函数作用域，所谓函数作用域：&lt;strong&gt;变量在其所声明的函数内的任意位置都是可访问的&lt;/strong&gt;，这里就引出了JS变量的函数提升，对于code1，其实际的执行code可以改写如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i = 'out';
var test = function(){
	var i;
	console.log(i);
	i = 'in';
	console.log(i);
}
test();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到变量i的声明在函数内部是被提升到了开始的位置，但是赋值的位置确是不变的。类似的code2可以改写为:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i;
var i; 
i = 'out';
if(true){
	i = 'in'
	console.log(i);
}
console.log(i);

test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;i在if中被修改了&lt;/p&gt;

&lt;h3 id=&quot;作用域链&quot;&gt;作用域链&lt;/h3&gt;

&lt;p&gt;当代码在环境中执行的时候，会创建变量对象的一个作用域链（scope chain）。其用途是&lt;strong&gt;保证能够有序访问当前环境中的变量和函数&lt;/strong&gt;。作用域链的前端始终是当前代码所在的变量对象，下一个变量对象总是外部环境的变量对象。&lt;strong&gt;标识符解析时,总是沿着作用域链从前端向后逐层的搜索&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;环境之前的联系是&lt;strong&gt;线性有序&lt;/strong&gt;的,内部环境是可以通过作用域链访问所有外部环境，但是外部环境不能访问内部环境。所以引发了&lt;strong&gt;闭包&lt;/strong&gt;的概念&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;另使用with可以在作用域顶端添加某个对象，因为有可能造成混淆和兼容错误，所以不被推荐使用，不过在某些情况下可以减少不必要的作用域链搜索过程并简化代码，当然，这种简化方式用一个指针也可以做到。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var a, x, y;
var r = 10;

with (Math) {
  a = PI * r * r;
  x = r * cos(PI);
  y = r * sin(PI / 2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;闭包&quot;&gt;闭包&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;闭包就是能够读取其他函数内部变量的函数&lt;/strong&gt;, 本质上是将函数内部和外部联系起来的桥梁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;function f1(){
	var n=999;
	function add(){
		n++;
		alert(n);
	}
	return add;
}
var result=f1();
result();//1000
result();//1001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码通过内部的add在函数f1之外操作内部变量n，这里还体现了一个闭包的特点，可以看到在f1执行一次后n的值是被保存的，这是因为f2第一次在调用时被赋给了一个全局变量，而f2依赖于f1，所以f1的环境也始终被保存在内存中，不会被垃圾回收机制回收，所以&lt;strong&gt;大量使用闭包内存消耗很大，会导致性能下降&lt;/strong&gt;&amp;gt;，第二个要注意地方时&lt;strong&gt;函数内部的值可能会被修改&lt;/strong&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript-Note(1)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript-Note(1)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>Array去重的多种实现和分析</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Move on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;有趣的小问题，似乎经常在面试中出现&lt;/p&gt;

&lt;h3 id=&quot;方法一-双层循环&quot;&gt;方法一: 双层循环&lt;/h3&gt;

&lt;p&gt;外层循环遍历数组，内层循环判断重复，检测到重复即break，无重复则Push进结果数组。&lt;/p&gt;

&lt;p&gt;利用Array.prototype.indexOf()可以简化如下：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度O(n^2)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;方法二-排序&quot;&gt;方法二: 排序&lt;/h3&gt;

&lt;p&gt;先排序后从第二项循环，和前一项不同则加入&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度O(log(n)+n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;方法三-利用hash&quot;&gt;方法三: 利用hash&lt;/h3&gt;

&lt;p&gt;使用一个Object做hash，循环检测当前想是否在hash中，没有则加入hash并加入数组&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; 
		&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
		 	&lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		 	&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;时间复杂度O(n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;方法四-利用es6的set&quot;&gt;方法四: 利用ES6的Set&lt;/h3&gt;

&lt;p&gt;数组构造set会自动去重，set再展开为数组，代码最简洁&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;Array.prototype.unique = function(){
	return [...new Set(this)];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;效率分析&quot;&gt;效率分析&lt;/h2&gt;

&lt;p&gt;使用随机函数分别生成length为10^3，10^4，10^5，10^6的随机数，范围为0-500的整数。&lt;/p&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;p&gt;10^3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^3.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10^4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^4.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10^5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^5.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10^6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^6.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;

&lt;p&gt;可以看到前两种方法使用的时间比后两种高一个数量级，相对而言，第二种排序的方法最耗时；而后两种中，使用set的方法比使用hash的方法更加耗时，所以从耗时的角度，最好的是使用方法三，即使用hash记录，从代码简洁的角度，利用set的机制最好，并且耗时和方法三也在一个数量级。&lt;/p&gt;

&lt;h3 id=&quot;test-code&quot;&gt;Test code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;Array.prototype.unique1 = function() {
	var res = [];
	this.forEach(function(item){
		if(res.indexOf(item) &amp;lt; 0){
			res.push(item);
		}
	});
	return res;
};


Array.prototype.unique2 = function() {
	var res = [this[0]];
	this.sort();
	for(let i = 1; i &amp;lt; this.length; i++){
		if(this[i] !== this[i-1]){
			res.push(this[i])
		}
	}
	return res;
};

Array.prototype.unique3 = function() {
	var hash = {}, 
		res = [];
	this.forEach(function(item){
		if(!hash[item]){
		 	hash[item] = true;
		 	res.push(item);
		}
	});
	return res;
};

Array.prototype.unique4 = function(){
	return [...new Set(this)];
}

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive
}

var count = 10000000;
var testArray = [];
for(let i =0 ; i &amp;lt; count; i++){
	testArray.push(getRandomInt(0,500))
}
var start = new Date().getTime();
console.log(testArray.unique1());
var end = new Date().getTime();
console.log(&quot;unique1: &quot; + (end - start) + &quot;ms&quot;);

var start = new Date().getTime();
console.log(testArray.unique2());
var end = new Date().getTime();
console.log(&quot;unique2: &quot; + (end - start) + &quot;ms&quot;);

var start = new Date().getTime();
console.log(testArray.unique3());
var end = new Date().getTime();
console.log(&quot;unique3: &quot; + (end - start) + &quot;ms&quot;);

var start = new Date().getTime();
console.log(testArray.unique4());
var end = new Date().getTime();
console.log(&quot;unique4: &quot; + (end - start) + &quot;ms&quot;);
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/Array%E5%8E%BB%E9%87%8D%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/Array%E5%8E%BB%E9%87%8D%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>Walkways Problem</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;前段时间看到一篇文章，其中讨论了陶哲轩（Terrence Tao）blog上提出的一个数学问题，文章并没有给出明确的解答，在此记录自己的一点思考：&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;Suppose you are trying to get from one end A of a terminal to the other end B. (For simplicity, assume the terminal is a one-dimensional line segment.) Some portions of the terminal have moving walkways (in both directions); other portions do not. Your walking speed is a constant v, but while on a walkway, it is boosted by the speed u of the walkway for a net speed of v+u. (Obviously, given a choice, one would only take those walkways that are going in the direction one wishes to travel in.) Your objective is to get from A to B in the shortest time possible.&lt;/p&gt;

&lt;p&gt;在机场中，你想从A点前往B点。（为了将问题简化，假设机场是一条线性通道。）一些区域有电动扶梯（双向的），另一些区域没有。你的步行速度恒定为v，电动扶梯的运行速度为u，因此在扶梯上，你的实际速度为v+u。（显然，你不会搭乘与你前进方向不一致的扶梯。）你的目标是尽可能快地从A点到达B点。&lt;/p&gt;

&lt;h3 id=&quot;问题1&quot;&gt;问题1&lt;/h3&gt;
&lt;p&gt;Suppose you need to pause for some period of time, say to tie your shoe. Is it more efficient to do so while on a walkway, or off the walkway? Assume the period of time required is the same in both cases.&lt;/p&gt;

&lt;p&gt;假定你需要暂停片刻，比如系鞋带。请问你应该在电动扶梯上系，还是在没有上电动扶梯时系？假定两种情况下，系鞋带的时间相同。&lt;/p&gt;

&lt;h3 id=&quot;问题2&quot;&gt;问题2&lt;/h3&gt;
&lt;p&gt;Suppose you have a limited amount of energy available to run and increase your speed to a higher quantity v’ (or v’+u, if you are on a walkway). Is it more efficient to run while on a walkway, or off the walkway? Assume that the energy expenditure is the same in both cases.&lt;/p&gt;

&lt;p&gt;假定你有有限数量的多余能量，用来奔跑。在跑动时，你的速度提高到v’（如果在电动扶梯上，就相应为v’+u）。请问你应该在电动扶梯上跑，还是在没有上电动扶梯时跑？假定两种情况下，你可供奔跑的能量相同。&lt;/p&gt;

&lt;h3 id=&quot;问题3&quot;&gt;问题3&lt;/h3&gt;
&lt;p&gt;Do the answers to the above questions change if one takes into account the various effects of special relativity? (This is of course an academic question rather than a practical one. But presumably it should be the time in the airport frame that one wants to minimise, not time in one’s personal frame.)&lt;/p&gt;

&lt;p&gt;在狭义相对论的情况下，上述答案是否发生改变？&lt;/p&gt;

&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;

&lt;p&gt;首先，第一问很简单，肯定是在电梯上，主要讨论第二问：&lt;/p&gt;

&lt;p&gt;设想有3个人，A不加速，B行走时加速，C扶梯时加速。加速值记为dV，加速时间记为dT。&lt;/p&gt;

&lt;p&gt;假设A和B先比赛，从起点到终点A和B都是先扶梯再走路，A和B同时下扶梯，B到终点时，A落后 dS=dV*dT 距离，相当于B领先A dS/v 时间。&lt;/p&gt;

&lt;p&gt;假设A和C后比赛，是同一段路反向走，即先走路后电梯，则A与C同一时间走上扶梯，C到终点（也是扶梯终点）时，A仍然落后 dS=dV*dT 距离，但A只用 dS/(v+u) 时间即可到达终点
由于是同一段路A只是正反向走
因此，B最快，C次之，A最慢。&lt;/p&gt;

&lt;p&gt;还可以这么解释我觉得也不错，时间是匀速流逝的前提下，当然是要充分利用传送带，因为传送带的长度是固定，所以鞋带留在传送带上系，加速在地面来做。属于一种“边际效益递减”。&lt;/p&gt;

&lt;hr /&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/Walkways-Problem/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/Walkways-Problem/</guid>
        
        <category>Math</category>
        
        
      </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Run Note</title>
    <description></description>
    <link>http://localhost:4000/lrun1124.github.io/</link>
    <atom:link href="http://localhost:4000/lrun1124.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 28 Nov 2017 19:52:02 +0800</pubDate>
    <lastBuildDate>Tue, 28 Nov 2017 19:52:02 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>JavaScrip Note(二)</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;This的理解&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;this总是指向函数的直接调用者（而非简洁调用者）,即此次调用的所有者&lt;/li&gt;
  &lt;li&gt;如果有new对象，this指向new出来的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;Eval&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Eval将传入的字符串当做JS代码执行, 应避免在不必要的情况下使用
    &lt;ul&gt;
      &lt;li&gt;运行Eval存在风险，有可能运行的是恶意代码&lt;/li&gt;
      &lt;li&gt;运行效率差，因为会调用JS解析器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;

&lt;p&gt;window对象和document对象&lt;/p&gt;

&lt;p&gt;window对象是浏览器打开的窗口，顶层对象，document是window对象的一个属性，HTML文档对象的一个&lt;strong&gt;只读引用&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;

&lt;p&gt;IE和firefox事件机制&lt;/p&gt;

&lt;p&gt;IE是事件冒泡，firefox同时支持事件冒泡和捕获&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;时间捕获: 越高层的元素越早接收到事件，由上到下&lt;/li&gt;
  &lt;li&gt;事件冒泡: 越低层的元素越早接收到时间，由下到上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组织冒泡事件的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;xxx.click = function(e){
	e.stopPropagation();
	e.cancelBubble = true;//旧IE需要
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;

&lt;p&gt;new的过程&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建空对象；
    &lt;ul&gt;
      &lt;li&gt;var obj = {};&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将创建出对象的原型链引用指向所要构造函数的原型；
    &lt;ul&gt;
      &lt;li&gt;obj.__proto__ = ClassA.prototype;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;调用构造函数，this指向新实例对象：
    &lt;ul&gt;
      &lt;li&gt;ClassA.call(obj);　　//{}.构造函数();&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将初始化完毕的新对象地址，保存到等号左边的变量中&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;

&lt;p&gt;JS中不会查找原型的函数&lt;/p&gt;

&lt;p&gt;hasOwnProperty判断对象中是否有指定名称的属性，object.hasOwnProperty(proName)，proName是属性名称的&lt;strong&gt;字符串值&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;7&quot;&gt;7&lt;/h3&gt;

&lt;p&gt;JSON的了解&lt;/p&gt;

&lt;p&gt;JSON（JavaScript Object Notation）是一种&lt;strong&gt;轻量级的数据交换格式&lt;/strong&gt;，是基于JavaScript的一个子集，具有&lt;strong&gt;数据格式简单，易于读写且占用带宽小&lt;/strong&gt;的优点。&lt;/p&gt;

&lt;p&gt;字符串转对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;JSON.parse(str);
str.parseJSON(str);
eval('(' + str + ')')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象转字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;JSON.stringify(obj);
obj.toJSONString(str);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8&quot;&gt;8&lt;/h3&gt;

&lt;p&gt;Ajax&lt;/p&gt;

&lt;p&gt;Asynchronous JavaScript and Xml, 异步传输+JS+xml，异步的含义是在向服务器发送请求后，不必等待响应，可以先做其他的事，等相应返回可以根据设定的callback函数进行操作，于此同时，网页不会发生整页刷新，提高了效率和用户体验。&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建XMLHttpRequest对象&lt;/li&gt;
  &lt;li&gt;设置响应HTTP请求状态变化的函数&lt;/li&gt;
  &lt;li&gt;指定该对象的的方法、URL及验证信息&lt;/li&gt;
  &lt;li&gt;发送HTTP请求&lt;/li&gt;
  &lt;li&gt;获取异步调用返回的数据&lt;/li&gt;
  &lt;li&gt;使用JavaScript和DOM实现局部刷新&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button id=&quot;ajaxButton&quot; type =&quot;button&quot;&amp;gt;Make Ajax request&amp;lt;/button&amp;gt;

&amp;lt;script&amp;gt;
var httpRequest;
document.getElementbyId('ajaxButton').addEventListener(&quot;click&quot;, sendRequest);

function sendRequest(){
	httpRequest = new XMLHttpRequest(); //1

	if(httpRequest){
		alert('Cannot creat XMLHttpRequest');
		return;
	}

	httpRequest.onreadystatechange = stateFunction;//2
	httpRequest.open('GET', 'test.html');//3
	httpRequest.send();//4
}

function stateFunction(){
	if(httpRequest.readyState === XMLHttpRequet.Done){
		if(httpRequest.state === 200){
			alert(httpRequest.responseText);//5
			//... 6
		}
		else{
			alert('The request has some problem');
		}
	}
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;9&quot;&gt;9&lt;/h3&gt;

&lt;p&gt;JS延迟加载方式&lt;/p&gt;

&lt;p&gt;JS延迟加载就是在页面加载完成后再加载JS文件，有助于提高页面加载速度，提高用户体验。&lt;/p&gt;

&lt;h4 id=&quot;使用defer或async属性&quot;&gt;使用defer或async属性&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;test1.js&quot; defer=&quot;defer&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;test2.js&quot; async&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;只适用于外部脚本，缺点是不能保证脚本会按顺序执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;动态dom操作&quot;&gt;动态DOM操作&lt;/h4&gt;

&lt;p&gt;即利用动态DOM操作按需插入JS文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//延迟1000ms加载new.js
window.onload = function(){
	setTimeout(function(){
		var head = document.getEßlementByTagName('head')[0];
		var js = document.createElement('Script');
		js.type = 'text/javascript';
		js.src = 'new.js';
		head.appendChlid(js); 
	},1000);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;分组最后加载js&quot;&gt;分组最后加载JS&lt;/h4&gt;

&lt;p&gt;JS的引入如果放在head中，则页面加载前就会JS就会被加载，如果放在body中，则会按顺序加载，所以可以将JS分组，将加载过程中不需要的JS放在页面的底部，&amp;lt;/body&amp;gt;标签之前，然而这种方法偶尔会收到Google页面速度测试工具的“延迟加载javascript”警告，Google提供了一套推荐方案：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//这些代码应被放置在&amp;lt;/body&amp;gt;标签前(接近HTML文件底部)
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    function downloadJSAtOnload() {
        var element = document.createElement(&quot;script&quot;);
        element.src = &quot;defer.js&quot;;
        document.body.appendChild(element);
    }
    if (window.addEventListener)
        window.addEventListener(&quot;load&quot;, downloadJSAtOnload, false);
    else if (window.attachEvent)
        window.attachEvent(&quot;onload&quot;, downloadJSAtOnload);
    else window.onload = downloadJSAtOnload;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码意思是等到整个文档加载完后，再加载外部文件“defer.js”。&lt;/p&gt;

&lt;p&gt;使用此段代码的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;复制上面代码；&lt;/li&gt;
  &lt;li&gt;粘贴代码放置在&amp;lt;/body&amp;gt;标签前 (靠近HTML文件底部)；&lt;/li&gt;
  &lt;li&gt;修改“defer.js”为外部JS文件名；&lt;/li&gt;
  &lt;li&gt;确保文件路径是正确的。例如：如果仅输入“defer.js”，那么“defer.js”文件一定与HTML文件在同一文件夹下。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;注意：这段代码直到文档加载完才会加载指定的外部js文件。因此，不应该把那些页面正常加载需要依赖的javascript代码放在这里。而应该将JavaScript代码分成两组。&lt;strong&gt;一组是因页面需要而立即加载的javascript代码，另外一组是在页面加载后进行操作的javascript代码(例如添加click事件或其他东西)&lt;/strong&gt;。这些需等到页面加载后再执行的JavaScript代码，应放在一个外部文件，然后再引进来。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 24 Nov 2017 03:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/24/JavaScript%E5%9F%BA%E7%A1%80(%E4%BA%8C)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/24/JavaScript%E5%9F%BA%E7%A1%80(%E4%BA%8C)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Practice</title>
        <description>&lt;h2 id=&quot;1&quot;&gt;1&lt;/h2&gt;

&lt;p&gt;如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;//先找到'.'的位置或末尾，依次向前拼接直到头部
function transfer(num){
	let str = num + '';
	let i = (str.indexOf('.') &amp;gt; 0 ? str.indexOf('.') : str.length) - 3;
	for(; i&amp;gt;0; i-=3){
		str = str.substring(0, i) + ',' + str.substring(i);
	}
	return str;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2&quot;&gt;2&lt;/h2&gt;

&lt;p&gt;数组随机排列&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法1:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;//Random位置插入新数组，删除原数组内元素
function arrayRandom(arr){
	let res = [],
		index;
	while(arr.length &amp;gt; 0){
		index = parseInt(Math.random() * arr.length);
		res.push(arr[index]);
		arr.splice(index,1)
	}
	return res;
}
//test
let arr = [1,2,3,4,5,6,7,8,9,10];
console.log(arrayRandom(arr));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;方法2:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;//利用Array.prototype.sort的compare function
function arrayRandom(arr){
	return arr.sort(function(){
		return Math.random() - 0.5;
		})
}
//test
let arr = [1,2,3,4,5,6,7,8,9,10];
console.log(arrayRandom(arr));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;3&quot;&gt;3&lt;/h2&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript-Pritice/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript-Pritice/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Note(一)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Step 1. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;转前端工作一年多后对JS的一些基础仍然存在盲区，记录一些note查漏补缺&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;js基本数据类型&quot;&gt;JS基本数据类型&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Boolean, null, undefined, String, Number&lt;/li&gt;
  &lt;li&gt;ES 2015 新增 : Symbol
    &lt;ul&gt;
      &lt;li&gt;独一无二的变量，由于对象中的方法属性可能在传递分享时被不小心修改或覆盖，用Symbol可以保证唯一性。let s = Symbol();&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;储存结构
    &lt;ul&gt;
      &lt;li&gt;基本(原始)数据类型在栈(stack)中存储，空间较小，大小固定，会被频繁调用；&lt;/li&gt;
      &lt;li&gt;引用数据类型大小不固定，放在堆中存储&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/jsbase/database.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;js内置对象&quot;&gt;JS内置对象&lt;/h3&gt;

&lt;p&gt;Object对象：所有对象的父对象，原型链最上层
数据封装对象：Array, Boolean, String, Number, Object
其他： Math, Date, RegExp, Error, Function&lt;/p&gt;

&lt;h3 id=&quot;null-undefined区别&quot;&gt;null, undefined区别&lt;/h3&gt;

&lt;p&gt;null表示一个对象没有值，一般是程序员显示声明，Js不会自己设置为null，typeof(null)为Object&lt;/p&gt;

&lt;p&gt;undefined表示一个变量声明了，但还没有初始化， typeof(undefined)为undefined&lt;/p&gt;

&lt;p&gt;null === undefined 为true, null == undefined为false，目前的JS环境中，它们的差别很小，同时存在是因为历史原因，Js初期的设计参考了C等语言，在C中，null可以自动转型为0，由于JS的设计者Brendan Eich认为‘无’的概念最好不是一个对象，并且JS早期缺乏错误处理机制，null自动转型为0可能会造成一些不被察觉的错误，所以设计了undefined&lt;/p&gt;

&lt;h3 id=&quot;js原型原型链&quot;&gt;JS原型，原型链&lt;/h3&gt;

&lt;p&gt;原型: JavaScript借鉴了面向对象语言‘一切皆是对象’的思想，对于每一个对象都存在一个prototype对象，也就是原型，prototype属性默认有一个constructor属性指向对象本身。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/jsbase/prototype.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以内置对象Object为例，其prototype对象如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/jsbase/objectPrototype.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到其中包括了很多常用内置方法，在其他object调用这些方法的时候就是通过原型链生效的&lt;/p&gt;

&lt;p&gt;原型链: JS的继承是通过原型链实现的。当JS的对象需要某个属性的时候，首先会从当前对象的属性中去找，找不到就会到原型prototype中去找，还是找不到就会沿着原型链向上寻找，直到找到Object.prototype，如果最终找不到，则返回null&lt;/p&gt;

&lt;h3 id=&quot;作用域&quot;&gt;作用域&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;全局作用域
    &lt;ul&gt;
      &lt;li&gt;最外层定义的变量&lt;/li&gt;
      &lt;li&gt;未定义直接赋值的变量&lt;/li&gt;
      &lt;li&gt;顶层对象windows下的变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;局部作用域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JS的作用域和Java,C++之类语言最大的区别就在于它的函数作用域，对于一些熟悉Java,C++语言的人，会造成一些难以理解的结果。可以通过几个例子来看一下：&lt;/p&gt;

&lt;p&gt;code1：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i = 'out';
var test = function(){
	console.log(i);
	var i = 'in';
	console.log(i);
}
test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里运行结果是&lt;br /&gt;
undefined&lt;br /&gt;
in&lt;br /&gt;
而不是&lt;br /&gt;
out&lt;br /&gt;in&lt;/p&gt;

&lt;p&gt;code2：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i = 'out';
if(true){
	var i = 'in'
	console.log(i);
}
console.log(i);

test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里运行结果是&lt;br /&gt;
in&lt;br /&gt;
in&lt;br /&gt;
而不是&lt;br /&gt;
in&lt;br /&gt;
out&lt;/p&gt;

&lt;p&gt;造成结果的原因都是因为JS的函数作用域，所谓函数作用域：&lt;strong&gt;变量在其所声明的函数内的任意位置都是可访问的&lt;/strong&gt;，这里就引出了JS变量的函数提升，对于code1，其实际的执行code可以改写如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i = 'out';
var test = function(){
	var i;
	console.log(i);
	i = 'in';
	console.log(i);
}
test();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到变量i的声明在函数内部是被提升到了开始的位置，但是赋值的位置确是不变的。类似的code2可以改写为:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var i;
var i; 
i = 'out';
if(true){
	i = 'in'
	console.log(i);
}
console.log(i);

test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;i在if中被修改了&lt;/p&gt;

&lt;h3 id=&quot;作用域链&quot;&gt;作用域链&lt;/h3&gt;

&lt;p&gt;当代码在环境中执行的时候，会创建变量对象的一个作用域链（scope chain）。其用途是&lt;strong&gt;保证能够有序访问当前环境中的变量和函数&lt;/strong&gt;。作用域链的前端始终是当前代码所在的变量对象，下一个变量对象总是外部环境的变量对象。&lt;strong&gt;标识符解析时,总是沿着作用域链从前端向后逐层的搜索&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;环境之前的联系是&lt;strong&gt;线性有序&lt;/strong&gt;的,内部环境是可以通过作用域链访问所有外部环境，但是外部环境不能访问内部环境。所以引发了&lt;strong&gt;闭包&lt;/strong&gt;的概念&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;另使用with可以在作用域顶端添加某个对象，因为有可能造成混淆和兼容错误，所以不被推荐使用，不过在某些情况下可以减少不必要的作用域链搜索过程并简化代码，当然，这种简化方式用一个指针也可以做到。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;var a, x, y;
var r = 10;

with (Math) {
  a = PI * r * r;
  x = r * cos(PI);
  y = r * sin(PI / 2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;闭包&quot;&gt;闭包&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;闭包就是能够读取其他函数内部变量的函数&lt;/strong&gt;, 本质上是将函数内部和外部联系起来的桥梁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;function f1(){
	var n=999;
	function add(){
		n++;
		alert(n);
	}
	return add;
}
var result=f1();
result();//1000
result();//1001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码通过内部的add在函数f1之外操作内部变量n，这里还体现了一个闭包的特点，可以看到在f1执行一次后n的值是被保存的，这是因为f2第一次在调用时被赋给了一个全局变量，而f2依赖于f1，所以f1的环境也始终被保存在内存中，不会被垃圾回收机制回收，所以&lt;strong&gt;大量使用闭包内存消耗很大，会导致性能下降&lt;/strong&gt;&amp;gt;，第二个要注意地方时&lt;strong&gt;函数内部的值可能会被修改&lt;/strong&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript%E5%9F%BA%E7%A1%80(%E4%B8%80)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/JavaScript%E5%9F%BA%E7%A1%80(%E4%B8%80)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>Array去重的多种实现和分析</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Move on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;有趣的小问题，似乎经常在面试中出现&lt;/p&gt;

&lt;h3 id=&quot;方法一-双层循环&quot;&gt;方法一: 双层循环&lt;/h3&gt;

&lt;p&gt;外层循环遍历数组，内层循环判断重复，检测到重复即break，无重复则Push进结果数组。&lt;/p&gt;

&lt;p&gt;利用Array.prototype.indexOf()可以简化如下：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度O(n^2)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;方法二-排序&quot;&gt;方法二: 排序&lt;/h3&gt;

&lt;p&gt;先排序后从第二项循环，和前一项不同则加入&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度O(log(n)+n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;方法三-利用hash&quot;&gt;方法三: 利用hash&lt;/h3&gt;

&lt;p&gt;使用一个Object做hash，循环检测当前想是否在hash中，没有则加入hash并加入数组&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; 
		&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
		 	&lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		 	&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;时间复杂度O(n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;方法四-利用es6的set&quot;&gt;方法四: 利用ES6的Set&lt;/h3&gt;

&lt;p&gt;数组构造set会自动去重，set再展开为数组，代码最简洁&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;Array.prototype.unique = function(){
	return [...new Set(this)];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;效率分析&quot;&gt;效率分析&lt;/h2&gt;

&lt;p&gt;使用随机函数分别生成length为10^3，10^4，10^5，10^6的随机数，范围为0-500的整数。&lt;/p&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;p&gt;10^3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^3.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10^4&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^4.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10^5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^5.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10^6&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/ArrayUnique/ArrayUnique_10^6.png&quot; width=&quot;450&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;

&lt;p&gt;可以看到前两种方法使用的时间比后两种高一个数量级，相对而言，第二种排序的方法最耗时；而后两种中，使用set的方法比使用hash的方法更加耗时，所以从耗时的角度，最好的是使用方法三，即使用hash记录，从代码简洁的角度，利用set的机制最好，并且耗时和方法三也在一个数量级。&lt;/p&gt;

&lt;h3 id=&quot;test-code&quot;&gt;Test code&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;Array.prototype.unique1 = function() {
	var res = [];
	this.forEach(function(item){
		if(res.indexOf(item) &amp;lt; 0){
			res.push(item);
		}
	});
	return res;
};


Array.prototype.unique2 = function() {
	var res = [this[0]];
	this.sort();
	for(let i = 1; i &amp;lt; this.length; i++){
		if(this[i] !== this[i-1]){
			res.push(this[i])
		}
	}
	return res;
};

Array.prototype.unique3 = function() {
	var hash = {}, 
		res = [];
	this.forEach(function(item){
		if(!hash[item]){
		 	hash[item] = true;
		 	res.push(item);
		}
	});
	return res;
};

Array.prototype.unique4 = function(){
	return [...new Set(this)];
}

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive
}

var count = 10000000;
var testArray = [];
for(let i =0 ; i &amp;lt; count; i++){
	testArray.push(getRandomInt(0,500))
}
var start = new Date().getTime();
console.log(testArray.unique1());
var end = new Date().getTime();
console.log(&quot;unique1: &quot; + (end - start) + &quot;ms&quot;);

var start = new Date().getTime();
console.log(testArray.unique2());
var end = new Date().getTime();
console.log(&quot;unique2: &quot; + (end - start) + &quot;ms&quot;);

var start = new Date().getTime();
console.log(testArray.unique3());
var end = new Date().getTime();
console.log(&quot;unique3: &quot; + (end - start) + &quot;ms&quot;);

var start = new Date().getTime();
console.log(testArray.unique4());
var end = new Date().getTime();
console.log(&quot;unique4: &quot; + (end - start) + &quot;ms&quot;);
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/Array%E5%8E%BB%E9%87%8D%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/Array%E5%8E%BB%E9%87%8D%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>Walkways Problem</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;前段时间看到一篇文章，其中讨论了陶哲轩（Terrence Tao）blog上提出的一个数学问题，文章并没有给出明确的解答，在此记录自己的一点思考：&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;Suppose you are trying to get from one end A of a terminal to the other end B. (For simplicity, assume the terminal is a one-dimensional line segment.) Some portions of the terminal have moving walkways (in both directions); other portions do not. Your walking speed is a constant v, but while on a walkway, it is boosted by the speed u of the walkway for a net speed of v+u. (Obviously, given a choice, one would only take those walkways that are going in the direction one wishes to travel in.) Your objective is to get from A to B in the shortest time possible.&lt;/p&gt;

&lt;p&gt;在机场中，你想从A点前往B点。（为了将问题简化，假设机场是一条线性通道。）一些区域有电动扶梯（双向的），另一些区域没有。你的步行速度恒定为v，电动扶梯的运行速度为u，因此在扶梯上，你的实际速度为v+u。（显然，你不会搭乘与你前进方向不一致的扶梯。）你的目标是尽可能快地从A点到达B点。&lt;/p&gt;

&lt;h3 id=&quot;问题1&quot;&gt;问题1&lt;/h3&gt;
&lt;p&gt;Suppose you need to pause for some period of time, say to tie your shoe. Is it more efficient to do so while on a walkway, or off the walkway? Assume the period of time required is the same in both cases.&lt;/p&gt;

&lt;p&gt;假定你需要暂停片刻，比如系鞋带。请问你应该在电动扶梯上系，还是在没有上电动扶梯时系？假定两种情况下，系鞋带的时间相同。&lt;/p&gt;

&lt;h3 id=&quot;问题2&quot;&gt;问题2&lt;/h3&gt;
&lt;p&gt;Suppose you have a limited amount of energy available to run and increase your speed to a higher quantity v’ (or v’+u, if you are on a walkway). Is it more efficient to run while on a walkway, or off the walkway? Assume that the energy expenditure is the same in both cases.&lt;/p&gt;

&lt;p&gt;假定你有有限数量的多余能量，用来奔跑。在跑动时，你的速度提高到v’（如果在电动扶梯上，就相应为v’+u）。请问你应该在电动扶梯上跑，还是在没有上电动扶梯时跑？假定两种情况下，你可供奔跑的能量相同。&lt;/p&gt;

&lt;h3 id=&quot;问题3&quot;&gt;问题3&lt;/h3&gt;
&lt;p&gt;Do the answers to the above questions change if one takes into account the various effects of special relativity? (This is of course an academic question rather than a practical one. But presumably it should be the time in the airport frame that one wants to minimise, not time in one’s personal frame.)&lt;/p&gt;

&lt;p&gt;在狭义相对论的情况下，上述答案是否发生改变？&lt;/p&gt;

&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;

&lt;p&gt;首先，第一问很简单，肯定是在电梯上，主要讨论第二问：&lt;/p&gt;

&lt;p&gt;设想有3个人，A不加速，B行走时加速，C扶梯时加速。加速值记为dV，加速时间记为dT。&lt;/p&gt;

&lt;p&gt;假设A和B先比赛，从起点到终点A和B都是先扶梯再走路，A和B同时下扶梯，B到终点时，A落后 dS=dV*dT 距离，相当于B领先A dS/v 时间。&lt;/p&gt;

&lt;p&gt;假设A和C后比赛，是同一段路反向走，即先走路后电梯，则A与C同一时间走上扶梯，C到终点（也是扶梯终点）时，A仍然落后 dS=dV*dT 距离，但A只用 dS/(v+u) 时间即可到达终点
由于是同一段路A只是正反向走
因此，B最快，C次之，A最慢。&lt;/p&gt;

&lt;p&gt;还可以这么解释我觉得也不错，时间是匀速流逝的前提下，当然是要充分利用传送带，因为传送带的长度是固定，所以鞋带留在传送带上系，加速在地面来做。属于一种“边际效益递减”。&lt;/p&gt;

&lt;hr /&gt;
</description>
        <pubDate>Tue, 07 Nov 2017 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/07/Walkways-Problem/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/07/Walkways-Problem/</guid>
        
        <category>Math</category>
        
        
      </item>
    
  </channel>
</rss>

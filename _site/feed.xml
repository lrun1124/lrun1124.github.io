<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Run Note</title>
    <description></description>
    <link>http://localhost:4000/lrun1124.github.io/</link>
    <atom:link href="http://localhost:4000/lrun1124.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 05 Sep 2019 11:06:19 +0800</pubDate>
    <lastBuildDate>Thu, 05 Sep 2019 11:06:19 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>V8 GC机制</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Move on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;引用计数&quot;&gt;引用计数&lt;/h2&gt;

&lt;p&gt;传统的GC方法，维护对象的引用计数器，引用为0时清除，优点是清除及时，清除时间均匀分布，缺点主要是循环引用问题&lt;/p&gt;

&lt;h2 id=&quot;v8机制&quot;&gt;V8机制&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/jsgc.png&quot; width=&quot;450&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将内存分为新生带和老生带两部分&lt;/p&gt;

&lt;h3 id=&quot;新生代&quot;&gt;新生代&lt;/h3&gt;

&lt;p&gt;Scavenge垃圾回收算法进行管理，主要实现是Cheney算法，将内存分为两部分，From和To，新建对象都进入From空间中，当From空间分配到一定程度，将存活对象对象copy到To空间，清空From空间，然后调换From和To空间，继续进行分配，当一个对象被多次移动后仍然存活，或者如果一个对象被复制到To空间，To空间占用超过阈值（25%），这个对象会被移到老生带&lt;/p&gt;

&lt;h3 id=&quot;老生带&quot;&gt;老生带&lt;/h3&gt;

&lt;p&gt;综合使用Mark-Sweep和Mark-compact, Mark-Sweep是当GC触发时，从根节点出发对所有能到达的对象进行遍历，一般是深度优先搜索，对能达到对象进行标记，最后清除掉未被标记的对象，Mark-Sweep会产生碎片内存，Mark-compact是将使用的内存向一侧移动，然后清楚掉内存的边界，由于Mark-compact需要移动对象，所以速度不会很快，V8上尽量才去Mark-Sweep，当内存不足以对新生代晋升过来的对象进行分配时，再进行Mark-compact&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Sep 2019 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2019/09/04/V8-GC%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2019/09/04/V8-GC%E6%9C%BA%E5%88%B6/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>N Sum problem</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Move on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;call&quot;&gt;call&lt;/h2&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myCall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'temp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;apply&quot;&gt;apply&lt;/h2&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myApply&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'temp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;bind&quot;&gt;bind&lt;/h2&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myBind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myApply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myBind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myApply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//不用前面的function&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myBind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'temp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 02 Sep 2019 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2019/09/02/%E5%AE%9E%E7%8E%B0call,apply,bind/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2019/09/02/%E5%AE%9E%E7%8E%B0call,apply,bind/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>N Sum problem</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Move on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;To do&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Aug 2019 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2019/08/27/N-Sum-problem/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2019/08/27/N-Sum-problem/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip值传递和引用传递</title>
        <description>&lt;p&gt;面试很容易碰到这个问题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;JavaScript是采用值传递还是引用传递的，并解释一下原理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很多人的回答应该是，基础类型采用值传递，Number其他采取引用查传递&lt;/p&gt;

&lt;p&gt;今天和一个刚转做前端的同事解释JS的值传递和引用传递，发现这句话其实很有问题。&lt;/p&gt;

&lt;p&gt;下面一段代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function reset(nums) {
  nums = [];
}
var nums = [1,2,3];
reset(nums);
console.log(nums);

//output:
//[1,2,3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Array属于引用传递，但是Array确并没有在reset函数中被重置。按照引用传递的含义，nums的引用（指针）被传递到函数内部，这个引用指向的内容变化了，nums也应该变化。所以这里存在问题。&lt;/p&gt;

&lt;p&gt;实际上还有一种传递方式，叫共享调用（Call-by-sharing), 它和引用调用的不同在于，传递的是对象指针的拷贝，而不是指针本身，那就是说nums在reset函数中是函数外nums的指针拷贝。&lt;/p&gt;

&lt;p&gt;从上面的解释可以看出，对于 JS 来说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;基本类型是传值调用（call by value）&lt;/li&gt;
  &lt;li&gt;引用类型传共享调用 (call by sharing)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传值调用本质上传递的是变量的值的拷贝。&lt;/p&gt;

&lt;p&gt;传共享调用本质上是传递对象的指针的拷贝，其指针也是变量的值。所以传共享调用也可以说是传值调用。&lt;/p&gt;

&lt;p&gt;所以《JavaScript 高级程序设计》说 JavaScript 参数传递都是按值传参也是有道理的。&lt;/p&gt;

</description>
        <pubDate>Wed, 24 Jul 2019 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2019/07/24/JavaScript%E5%80%BC%E4%BC%A0%E9%80%92and%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2019/07/24/JavaScript%E5%80%BC%E4%BC%A0%E9%80%92and%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>001_TwoSum</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Move on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;problem&quot;&gt;problem&lt;/h2&gt;

&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;

&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/p&gt;

&lt;p&gt;Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].&lt;/p&gt;

&lt;h2 id=&quot;solve&quot;&gt;solve&lt;/h2&gt;

&lt;p&gt;用一个map记录[value: index], 每次搜索tagert-nums[i], 匹配则返回，不匹配插入map&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;twoSum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 24 May 2019 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2019/05/24/001_TwoSum/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2019/05/24/001_TwoSum/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>Css Note</title>
        <description>&lt;h3 id=&quot;1-盒子模型&quot;&gt;1. 盒子模型&lt;/h3&gt;

&lt;p&gt;CSS的盒子模型，低版本IE的盒子模型有什么不同的？&lt;/p&gt;

&lt;p&gt;W3C标准盒子模型，content(内容)，padding(内边距)，border(边框)，margin(外边距)组成&lt;/p&gt;

&lt;p&gt;以margin：10px； border：2px； padding：5px； width：200px；height：100px 为例&lt;/p&gt;

&lt;p&gt;则整个盒子模型的宽是：10px&lt;em&gt;2 + 2px&lt;/em&gt;2 + 5px*2 + 200px = 234px&lt;/p&gt;

&lt;p&gt;则整个盒子模型的高是：10px&lt;em&gt;2 + 2px&lt;/em&gt;2 + 5px*2 + 100px = 134px&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/cssbase1/boxModelW3C.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;旧IE，主要是指IE5和（IE6的怪异模式），content部分的width和height是把padding和border也算了进去&lt;/p&gt;

&lt;p&gt;整个盒子模型的宽是： margin*2 + width（严格来说是：margin-left + width + margin-right&lt;/p&gt;

&lt;p&gt;整个盒子模型的高是： margin*2 + height（严格来说是：margin-left + height + margin-right）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/cssbase1/boxModelOldIE.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-css选择器&quot;&gt;2. CSS选择器&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;id选择器（# myid）&lt;/li&gt;
  &lt;li&gt;类选择器（.myclassname）&lt;/li&gt;
  &lt;li&gt;标签选择器（div, h1, p）&lt;/li&gt;
  &lt;li&gt;相邻选择器（h1 + p）&lt;/li&gt;
  &lt;li&gt;子选择器（ul &amp;gt; li）&lt;/li&gt;
  &lt;li&gt;后代选择器（li a）&lt;/li&gt;
  &lt;li&gt;通配符选择器（ * ）&lt;/li&gt;
  &lt;li&gt;属性选择器（a[rel = “external”]）&lt;/li&gt;
  &lt;li&gt;伪类选择器（a:hover, li:nth-child&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-display的值及作用&quot;&gt;3. display的值及作用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;block       	块类型。默认宽度为父元素宽度，可设置宽高，换行显示。&lt;/li&gt;
  &lt;li&gt;none        	缺省值。象行内元素类型一样显示。&lt;/li&gt;
  &lt;li&gt;inline      	行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。&lt;/li&gt;
  &lt;li&gt;inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。&lt;/li&gt;
  &lt;li&gt;list-item   	象块类型元素一样显示，并添加样式列表标记。&lt;/li&gt;
  &lt;li&gt;table       	此元素会作为块级表格来显示。&lt;/li&gt;
  &lt;li&gt;inherit     	规定应该从父元素继承 display 属性的值。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-position属性定位原点&quot;&gt;4. position属性（定位原点）&lt;/h3&gt;

&lt;p&gt;absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。&lt;/p&gt;

&lt;p&gt;fixed （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。&lt;/p&gt;

&lt;p&gt;relative 生成相对定位的元素，相对于其正常位置进行定位。&lt;/p&gt;

&lt;p&gt;static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。&lt;/p&gt;

&lt;p&gt;inherit 规定从父元素继承 position 属性的值。&lt;/p&gt;

&lt;h3 id=&quot;5-居中div&quot;&gt;5. 居中div&lt;/h3&gt;

&lt;h4 id=&quot;水平居中&quot;&gt;水平居中&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;给div设置一个width，然后设置margin:0 auto;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div {
	width: 300px;
	margin: 0 auto;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;让绝对定位的div居中&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div {
	positive: absolute;
	width: 300px;
	height: 300px;
	margin: auto;
	top: 0;
	bottom: 0;
	left: 0;
	right: 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;水平垂直居中&quot;&gt;水平垂直居中&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;若已知容器的宽300px,高400px,则先用top和left将容器左上角定位到中心点位置，再通过设置margin移动div中心点到居中的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div {
	position: relative;	/* 相对定位或绝对定位均可 */
	width: 300px;
	height: 400px;
	top: 50%;
	left: 50%;
	margin: -200px 0 0 -150px;	/* 外边距为自身宽高的一半的负数 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;未知容器宽高，使用transform属性，定义2D转换&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div {
	position: relative;	/* 相对定位或绝对定位均可 */
	width: 300px;
	height: 400px;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);	/* 通过translate定义2D转换 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;flex布局&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; .container {
 	display: flex;
 	align-items: center; 		/* 垂直居中 */
 	justify-content: center;	/* 水平居中 */

 }
 .container div {
 	width: 100px;
 	height: 100px;
 	background-color: pink;		/* 方便看效果 */
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-flexbox弹性盒布局模型&quot;&gt;6. Flexbox（弹性盒布局模型)&lt;/h3&gt;

&lt;p&gt;一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。&lt;/p&gt;

&lt;p&gt;较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。
采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。
它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。
常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做居中，能对不同屏幕大小自适应。
在布局上有了比以前更加灵活的空间&lt;/p&gt;

&lt;p&gt;如何兼容低版本浏览器：手动实现响应式，为低版本浏览器些resize函数，根据浏览器窗口大小使用不同样式&lt;/p&gt;

&lt;h3 id=&quot;7-用纯css创建三角形&quot;&gt;7. 用纯css创建三角形&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//设置内容高宽为0，利用下边框border
div {
	width: 0;	//若不为0则为梯形
	height: 0;
	border-width: 20px;
	border-style: solid;
	border-color: transparent transparent red transparent;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;8-清除浮动&quot;&gt;8. 清除浮动&lt;/h3&gt;

&lt;p&gt;当容器的高度为auto时，若容器内部含有浮动元素，则容器的高度不能自动伸长，使得内容溢出到容器外部从而影响页面布局&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//会产生浮动问题的代码
.news {
  background-color: gray;
  border: solid 1px black;
  }

.news img {
  float: left;
  }

.news p {
  float: right;
  }

&amp;lt;div class=&quot;news&quot;&amp;gt;
&amp;lt;img src=&quot;news-pic.jpg&quot; /&amp;gt;
&amp;lt;p&amp;gt;some text&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;清除浮动的方法可以分为两大类：&lt;/p&gt;

&lt;h3 id=&quot;利用clear属性&quot;&gt;利用clear属性&lt;/h3&gt;

&lt;p&gt;1.使用带clear属性的空元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//会产生浮动问题的代码
.news {
  background-color: gray;
  border: solid 1px black;
  }

.news img {
  float: left;
  }

.news p {
  float: right;
  }

.clear {
	clear: both;
}

&amp;lt;div class=&quot;news&quot;&amp;gt;
&amp;lt;img src=&quot;news-pic.jpg&quot; /&amp;gt;
&amp;lt;p&amp;gt;some text&amp;lt;/p&amp;gt;
&amp;lt;div class=&quot;clear&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.若浮动元素后面有元素，给浮动元素后面的元素加clear属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.news {
  background-color: gray;
  border: solid 1px black;
  }

.news img {
  float: left;
  }

.news p {
  float: right;
  }

.content {
	clear: both;
}

&amp;lt;div class=&quot;news&quot;&amp;gt;
&amp;lt;img src=&quot;news-pic.jpg&quot; /&amp;gt;
&amp;lt;p&amp;gt;some text&amp;lt;/p&amp;gt;
&amp;lt;div class=&quot;content&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.使用CSS的:after伪元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格&quot;020&quot;或点&quot;.&quot;，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout
.news {
  background-color: gray;
  border: solid 1px black;
  }

.news img {
  float: left;
  }

.news p {
  float: right;
  }

.clearfix:after{
  content: &quot;020&quot;; 
  display: block; 
  height: 0; 
  clear: both; 
  visibility: hidden;  
  }

.clearfix {
  /* 触发 hasLayout */ 
  zoom: 1; 
  }

&amp;lt;div class=&quot;news clearfix&quot;&amp;gt;
&amp;lt;img src=&quot;news-pic.jpg&quot; /&amp;gt;
&amp;lt;p&amp;gt;some text&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;触发浮动元素父元素的bfc&quot;&gt;触发浮动元素父元素的BFC&lt;/h4&gt;

&lt;p&gt;(Block Formatting Contexts, 块级格式化上下文)，使该父元素可以包含浮动元素&lt;/p&gt;

&lt;p&gt;1.给浮动元素的容器添加overflow:hidden;或overflow:auto&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.news {
  background-color: gray;
  border: solid 1px black;
  overflow: hidden;
}

.news img {
  float: left;
}

.news p {
  float: right;
}

.clear {
	clear: both;
}

&amp;lt;div class=&quot;news&quot;&amp;gt;
&amp;lt;img src=&quot;news-pic.jpg&quot; /&amp;gt;
&amp;lt;p&amp;gt;some text&amp;lt;/p&amp;gt;
&amp;lt;div class=&quot;clear&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.给浮动的元素的容器添加浮动&lt;/p&gt;

&lt;p&gt;但是这样会使其整体浮动，影响布局，不推荐使用&lt;/p&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;

&lt;p&gt;在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。&lt;/p&gt;

&lt;p&gt;最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。&lt;/p&gt;

&lt;h3 id=&quot;9-css优化提高性能的方式&quot;&gt;9. CSS优化、提高性能的方式&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;选择器效率优化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读取选择器的原则是从右到左。因此，我们书写的右边的最后一个选择器，被称作关键选择器，对于效率有决定性影响。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;避免使用通配符&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不使用标签名或类名修饰ID规则：如果规则使用ID选择器作为关键选择器，不要给规则添加标签名。因为ID本身就是唯一的，添加标签名会不必要地降低匹配效率。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不使用标签名修饰类：相较于标签，类更具独特性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽量选择最具体的方式：造成低效的最简单粗暴的原因就是在标签上使用太多规则。给元素添加类可以更快细分到类方式，可以减少规则去匹配标签的时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关于后代选择器和子选择器：避免使用后代选择器，非要用的话建议用子选择器代替，但子选择器也要慎用，标签规则永远不要包含子选择器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;利用可继承性：没必要在一般内容上声明样式。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;提取项目的通用公有样式，增强可复用性；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;按模块编写组件；增强项目的协同开发性、可维护性和可扩展性；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;10-浏览器解析选择器过程&quot;&gt;10. 浏览器解析选择器过程&lt;/h3&gt;

&lt;p&gt;样式系统从关键选择器开始，然后向左移查找规则选择器的祖先元素，只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。&lt;/p&gt;

&lt;h3 id=&quot;11-全屏滚动原理&quot;&gt;11. 全屏滚动原理&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;计算当前浏览器屏幕高度(document.body.clientHeight)，每次翻页显示的内容高度即为屏幕高度&lt;/li&gt;
  &lt;li&gt;对鼠标滚轮事件进行监听，注意滚轮事件的浏览器兼容问题。&lt;/li&gt;
  &lt;li&gt;加入时间控制，如果不加滚动会过于灵敏，一次翻好几屏&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//html
&amp;lt;div id=&quot;wrap&quot;&amp;gt;
    &amp;lt;div id=&quot;main&quot;&amp;gt;
        &amp;lt;div id=&quot;page1&quot; class=&quot;page&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;page2&quot; class=&quot;page&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;page3&quot; class=&quot;page&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;page4&quot; class=&quot;page&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//css
&amp;lt;style type=&quot;text/css&quot;&amp;gt;
html,body{
    height:100%;
}
body,ul,li,a,p,div{padding:0px; margin:0px; font-size:14px;}
#wrap{
    overflow: hidden;
    width:100%;
}
#main{
    height:2944px;
    top:0;
    position: relative;
}
.page{
    width:100%;
    margin:0;
}
#page1{
    background:#E4E6CE;
}
#page2{
    background:#6CE26C;
}
#page3{
    background:#BF4938;
}
#page4{
    background:#2932E1;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//js
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var wrap = document.getElementById(&quot;wrap&quot;);
    var main = document.getElementById(&quot;main&quot;);
    var hei = document.body.clientHeight;
    wrap.style.height = hei + &quot;px&quot;;
    var obj = document.getElementsByTagName(&quot;div&quot;);
    for(var i=0;i&amp;lt;obj.length;i++){
        if(obj[i].className == 'page'){
             obj[i].style.height = hei + &quot;px&quot;;
        }
    }
    //如果不加时间控制，滚动会过度灵敏，一次翻好几屏
    var startTime = 0, //翻屏起始时间  
        endTime = 0,  
        now = 0;     
    //浏览器兼容      
    if ((navigator.userAgent.toLowerCase().indexOf(&quot;firefox&quot;)!=-1)){   
        document.addEventListener(&quot;DOMMouseScroll&quot;,scrollFun,false);        
    }  
    else if (document.addEventListener) {  
        document.addEventListener(&quot;mousewheel&quot;,scrollFun,false);  
    }  
    else if (document.attachEvent) {  
        document.attachEvent(&quot;onmousewheel&quot;,scrollFun);   
    }  
    else{  
        document.onmousewheel = scrollFun;  
    }  

    //滚动事件处理函数
    function scrollFun(event){
        startTime = new Date().getTime();  
        var delta = event.detail || (-event.wheelDelta);  
        //mousewheel事件中的 “event.wheelDelta” 属性值：返回的如果是正值说明滚轮是向上滚动
        //DOMMouseScroll事件中的 “event.detail” 属性值：返回的如果是负值说明滚轮是向上滚动
        if ((endTime - startTime) &amp;lt; -1000){
            if(delta&amp;gt;0 &amp;amp;&amp;amp; parseInt(main.offsetTop) &amp;gt; -(hei*3)){
                //向下滚动
                now = now - hei;
                toPage(now);
        } 
            if(delta&amp;lt;0 &amp;amp;&amp;amp; parseInt(main.offsetTop) &amp;lt; 0){
                //向上滚动
                    now = now + hei;
                    toPage(now);
            }
             endTime = new Date().getTime();  
        }
           else{  
                event.preventDefault();    
            }    
    }
     function toPage(now){        
         $(&quot;#main&quot;).animate({top:(now+'px')},1000);     //jquery实现动画效果
         //setTimeout(&quot;main.style.top = now + 'px'&quot;,1000);     javascript 实现动画效果
    }   
&amp;lt;/script
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;12-伪类和伪元素&quot;&gt;12. 伪类和伪元素&lt;/h3&gt;

&lt;p&gt;定义：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CSS 伪类用于向某些选择器添加特殊的效果。&lt;/li&gt;
  &lt;li&gt;CSS 伪元素用于将特殊的效果添加到某些选择器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/cssbase1/cssbase-class.jpg&quot; /&gt;
&lt;img src=&quot;http://lrun1124.github.io/img/cssbase1/cssbase-element.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。伪元素和伪类之所以这么容易混淆，是因为他们的效果类似而且写法相仿，但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:Pseudo-classes
::Pseudo-elements
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但因为兼容性的问题，所以现在大部分还是统一的单冒号，但是抛开兼容性的问题，在书写时应该尽可能养成好习惯，区分两者。&lt;/p&gt;

&lt;h3 id=&quot;cookie隔离&quot;&gt;Cookie隔离&lt;/h3&gt;

&lt;p&gt;cookie隔离技术和传统的多域名拆分请求，提高浏览器并发请求数有点类似，均是采用多域名来处理请求。&lt;/p&gt;

&lt;p&gt;传统做法是将css，js，图片等静态文件放在多个域名下面请求，这样就可以跨过浏览器对统一主机名并发连接数的限制，提高整体并发请求量。&lt;/p&gt;

&lt;p&gt;cookie隔离技术则是通过使用多个非主要域名来请求静态文件，如果静态文件都放在主域名下，那静态文件请求的时候带有的cookie的数据提交给server是非常浪费的，还不如隔离开。&lt;/p&gt;

&lt;p&gt;因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入webserver，也减少了webserver对cookie的处理分析环节，提高了webserver的http请求的解析速度。&lt;/p&gt;

&lt;h3 id=&quot;元素竖向的百分比&quot;&gt;元素竖向的百分比&lt;/h3&gt;

&lt;p&gt;对于竖直方向的margin和padding，参照父元素的宽度。
对于水平方向的margin和padding，也是参照父元素的宽度&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Dec 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/12/07/CSS-Note(1)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/12/07/CSS-Note(1)/</guid>
        
        <category>CSS</category>
        
        
      </item>
    
      <item>
        <title>Html Note</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;Doctype作用？标准模式与兼容模式各有什么区别?&lt;/p&gt;

&lt;p&gt;（1）、&amp;lt;!DOCTYPE&amp;gt;声明位于位于HTML文档中的第一行，处于 &amp;lt;html&amp;gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。&lt;/p&gt;

&lt;p&gt;（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;HTML5 为什么只需要写 &amp;lt;!DOCTYPE HTML&amp;gt;？&lt;/p&gt;

&lt;p&gt;HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；&lt;/p&gt;

&lt;p&gt;而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。&lt;/p&gt;

&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;

&lt;p&gt;行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？&lt;/p&gt;

&lt;p&gt;首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。&lt;/p&gt;

&lt;p&gt;（1）行内元素有：a b span img input select strong（强调的语气）&lt;/p&gt;

&lt;p&gt;（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p&lt;/p&gt;

&lt;p&gt;（3）常见的空元素：&amp;lt;br&amp;gt; &amp;lt;hr&amp;gt; &amp;lt;img&amp;gt; &amp;lt;input&amp;gt; &amp;lt;link&amp;gt; &amp;lt;meta&amp;gt;&lt;/p&gt;

  	鲜为人知的是：&amp;lt;area&amp;gt; &amp;lt;base&amp;gt; &amp;lt;col&amp;gt; &amp;lt;command&amp;gt; &amp;lt;embed&amp;gt; &amp;lt;keygen&amp;gt; &amp;lt;param&amp;gt; &amp;lt;source&amp;gt; &amp;lt;track&amp;gt; &amp;lt;wbr&amp;gt;

&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;

&lt;p&gt;页面导入样式时，使用link和@import有什么区别？&lt;/p&gt;

&lt;p&gt;(1) link属于HTML标签，而@import是CSS提供的;&lt;/p&gt;

&lt;p&gt;(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;&lt;/p&gt;

&lt;p&gt;(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;&lt;/p&gt;

&lt;p&gt;(4) link方式的样式的权重 高于@import的权重&lt;/p&gt;

&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;

&lt;p&gt;介绍一下你对浏览器内核的理解？&lt;/p&gt;

&lt;p&gt;主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。&lt;/p&gt;

&lt;p&gt;渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。&lt;/p&gt;

&lt;p&gt;JS引擎：解析和执行javascript来实现网页的动态效果。&lt;/p&gt;

&lt;p&gt;最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。&lt;/p&gt;

&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;

&lt;p&gt;常见的浏览器内核有哪些？&lt;/p&gt;

&lt;p&gt;Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]&lt;br /&gt;
  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等&lt;br /&gt;
  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]&lt;br /&gt;
  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]&lt;/p&gt;

&lt;h3 id=&quot;7&quot;&gt;7&lt;/h3&gt;

&lt;p&gt;html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
    &lt;ol&gt;
      &lt;li&gt;绘画 canvas;&lt;/li&gt;
      &lt;li&gt;用于媒介回放的 video 和 audio 元素;&lt;/li&gt;
      &lt;li&gt;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;&lt;/li&gt;
      &lt;li&gt;用来保存当前会话信息的sessionStorage，数据在浏览器关闭后自动删除;&lt;/li&gt;
      &lt;li&gt;语意化更好的内容元素，比如 article、footer、header、nav、section;&lt;/li&gt;
      &lt;li&gt;表单控件，calendar、date、time、email、url、search;&lt;/li&gt;
      &lt;li&gt;新的技术webworker, websocket, Geolocation;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;移除的元素：&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;纯表现的元素：basefont，big，center，font, s，strike，tt，u;&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;对可用性产生负面影响的元素：frame，frameset，noframes；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;支持HTML5新标签：
    &lt;ol&gt;
      &lt;li&gt;IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。&lt;/li&gt;
      &lt;li&gt;也可以直接使用成熟的框架、比如html5shim;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8&quot;&gt;8&lt;/h3&gt;

&lt;p&gt;XML,SGML,HTML,XHTML,HTML5&lt;/p&gt;

&lt;p&gt;他们都是ML，都是标记语言（Markup Language），所以不同就是前面的部分了。&lt;/p&gt;

&lt;p&gt;SGML(Standard Generalized Markup Language)，即标准通用标记语言, 是一种古老，复杂的标准&lt;/p&gt;

&lt;p&gt;HTML(HyperText Markup Language)，超文本标记语言，是语法较为松散的、不严格的Web语言，SGML的子集，其中的HTML5已经不是SGML的子集了&lt;/p&gt;

&lt;p&gt;XML（eXtensible Markup Language），可扩展标记语言，主要用于存储数据和结构，可扩展，SGML的子集&lt;/p&gt;

&lt;p&gt;XHTML（eXtensible HyperText Markup Language），可扩展超文本标记语言，基于XML，作用与HTML类似，但语法更严格。所有标签必须闭合，每一个属性都必须使用引号包住，所有&amp;lt;和&amp;amp;特殊符号用编码表示。&amp;lt;br&amp;gt;要写成&amp;lt;br /&amp;gt;，不能写为&amp;lt;BR /&amp;gt;（同hr）；使用了&amp;lt;p&amp;gt;之后必须有一个&amp;lt;/p&amp;gt;以结束段落。&lt;/p&gt;

&lt;h3 id=&quot;9&quot;&gt;9&lt;/h3&gt;

&lt;p&gt;HTML语义化&lt;/p&gt;

&lt;p&gt;就是用正确的标签做正确的事情。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;&lt;/li&gt;
  &lt;li&gt;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;&lt;/li&gt;
  &lt;li&gt;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;&lt;/li&gt;
  &lt;li&gt;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;10&quot;&gt;10&lt;/h3&gt;

&lt;p&gt;cookie, loaclStorage, sessionStorage&lt;/p&gt;

&lt;p&gt;cookie: 可设置失效时间，默认是浏览器关闭后，大小4K左右，每次都会携带在HTTP头中，这也是大小限制的原因，如果使用cookie保存过多数据会带来性能问题，主要用于保存密码等信息&lt;/p&gt;

&lt;p&gt;localStorage: 除非主动删除，否则永久保留，一般5M左右，仅在浏览器保存，不参与通信&lt;/p&gt;

&lt;p&gt;sessionStorage: 仅在当前会话下有效，刷新不删除，关闭页面或浏览器清除，一般5M左右，仅在浏览器保存，不参与通信&lt;/p&gt;

&lt;p&gt;另外sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。&lt;/p&gt;

&lt;h3 id=&quot;11&quot;&gt;11&lt;/h3&gt;

&lt;p&gt;浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？&lt;/p&gt;

&lt;p&gt;在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
离线的情况下，浏览器就直接使用离线存储的资源。&lt;/p&gt;

&lt;h3 id=&quot;12&quot;&gt;12&lt;/h3&gt;

&lt;p&gt;iframe缺点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;iframe会阻塞主页面的Onload事件；&lt;/li&gt;
  &lt;li&gt;搜索引擎的检索程序无法解读这种页面，不利于SEO;&lt;/li&gt;
  &lt;li&gt;iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
  动态给iframe添加src属性值，这样可以绕开以上两个问题。&lt;/p&gt;

&lt;h3 id=&quot;13&quot;&gt;13&lt;/h3&gt;

&lt;p&gt;Label的作用是什么？是怎么用的？&lt;/p&gt;

&lt;p&gt;&amp;lt;label&amp;gt; 标签为 input 元素定义标注（标记）。
label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。用for属性绑定id。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;
&amp;lt;label for=&quot;male&quot;&amp;gt;Male&amp;lt;/label&amp;gt;
&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&amp;gt;
&amp;lt;br /&amp;gt;
&amp;lt;label for=&quot;female&quot;&amp;gt;Female&amp;lt;/label&amp;gt;
&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;14&quot;&gt;14&lt;/h3&gt;

&lt;p&gt;title与h1的区别、b与strong的区别、i与em的区别？&lt;/p&gt;

&lt;p&gt;title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；&lt;/p&gt;

&lt;p&gt;strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&amp;lt;strong&amp;gt;会重读，而&amp;lt;B&amp;gt;是展示强调内容。&lt;/p&gt;

&lt;p&gt;i内容展示为斜体，em表示强调的文本；&lt;/p&gt;

&lt;p&gt;Physical Style Elements – 自然样式标签, 重在视觉作用&lt;br /&gt;
  b, i, u, s, pre&lt;br /&gt;
  Semantic Style Elements – 语义样式标签, 重在含义&lt;br /&gt;
  strong, em, ins, del, code&lt;br /&gt;
  应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;15&quot;&gt;15&lt;/h2&gt;
&lt;p&gt;Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?&lt;/p&gt;

&lt;p&gt;1）、&amp;lt;!DOCTYPE&amp;gt; 声明位于文档中的最前面，处于 &amp;lt;html&amp;gt; 标签之前。告知浏览器以何种模式来渲染文档。&lt;/p&gt;

&lt;p&gt;2）、严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。&lt;/p&gt;

&lt;p&gt;3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。&lt;/p&gt;

&lt;p&gt;4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。&lt;/p&gt;

&lt;p&gt;你知道多少种Doctype文档类型？&lt;/p&gt;

&lt;p&gt;该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档&lt;/p&gt;

&lt;h2 id=&quot;16&quot;&gt;16&lt;/h2&gt;

&lt;p&gt;如何实现浏览器内多个标签页之间的通信?&lt;/p&gt;

&lt;p&gt;调用localstorge、cookies等本地存储方式&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Dec 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/12/06/Html-Note(1)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/12/06/Html-Note(1)/</guid>
        
        <category>Html</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Note(4)</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;前端设计模式&lt;/p&gt;

&lt;h4 id=&quot;单体模式singleton&quot;&gt;单体模式(Singleton)&lt;/h4&gt;

&lt;p&gt;将一批属性和方法组织在一起的对象，用来划分命名空间。其特点：&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;划分命名空间，只暴露一个入口，减少全局变量带来的风险&lt;/li&gt;
  &lt;li&gt;利用分支技术来来封装浏览器之间的差异。&lt;/li&gt;
  &lt;li&gt;可以把代码组织的更为一体，便于阅读和维护。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var singleton = {
    attribute: {},
    method1: function(){},
    method2: function(){}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;单例模式single&quot;&gt;单例模式(Single)&lt;/h4&gt;

&lt;p&gt;单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var single = (function(){
    var unique;

    function getInstance(){　　　　// 如果该实例存在，则直接返回，否则就对其实例化
        if( unique === undefined ){
            unique = new Construct();
        }
        return unique;
    }

    function Construct(){
        // ... 生成单例的构造函数的代码
    }

    return {
        getInstance : getInstance
    }
})();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;工厂模式factory&quot;&gt;工厂模式(Factory)&lt;/h4&gt;

&lt;p&gt;提供一个创建对象的借口，无需指定具体的类，把成员对象的创建工作转交给一个外部对象，&lt;strong&gt;好处在于消除对象之间的耦合(也就是相互影响), 有助于创建模块化的代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单工厂模式&lt;/strong&gt;：使用一个类，通常为单体，来生成实例。典型的实例，xhr工厂。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   var XMLHttpFactory =function(){};　　　　　　//这是一个简单工厂模式
　　XMLHttpFactory.createXMLHttp =function(){
　　　 var XMLHttp = null;
　　　　if (window.XMLHttpRequest){
　　　　　　XMLHttp = new XMLHttpRequest()
　　　 }else if (window.ActiveXObject){
　　　　　　XMLHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
　　　　}
　　return XMLHttp;
　　}
　　//XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。
　　var AjaxHander =function(){
　　　　var XMLHttp = XMLHttpFactory.createXMLHttp();
　　　　...
　　}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;复杂工厂模式&lt;/strong&gt;：先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var XMLHttpFactory =function(){};　     //这是一个抽象工厂模式

XMLHttpFactory.prototype = {
　　//如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类
　　createFactory:function(){
  　　throw new Error('This is an abstract class');
　　}
}

var XHRHandler =function(){}; //定义一个子类

// 子类继承父类原型方法
extend( XHRHandler , XMLHttpFactory );

XHRHandler.prototype =new XMLHttpFactory(); //把超类原型引用传递给子类,实现继承

XHRHandler.prototype.constructor = XHRHandler; //重置子类原型的构造器为子类自身

//重新定义createFactory 方法
XHRHandler.prototype.createFactory =function(){
　　var XMLHttp =null;
　　if (window.XMLHttpRequest){

  　　XMLHttp =new XMLHttpRequest();

　　}else if (window.ActiveXObject){

  　　XMLHttp =new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
　　}

　　return XMLHttp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;应用场景：&lt;/p&gt;

&lt;p&gt;以下几种情景下工厂模式特别有用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象的构建十分复杂&lt;/li&gt;
  &lt;li&gt;需要依赖具体环境创建不同实例&lt;/li&gt;
  &lt;li&gt;处理大量具有相同属性的小对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;可以实现一些相同的方法，这些相同的方法我们可以放在父类中编写代码，那么需要实现具体的业务逻辑，那么可以放在子类中重写该父类的方法，去实现自己的业务逻辑；&lt;/p&gt;

&lt;p&gt;也就是说有两点：　　&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。&lt;/li&gt;
  &lt;li&gt;重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;当工厂增加到一定程度的时候，提升了代码的复杂度，可读性下降。而且没有解决对象的识别问题，即怎么知道一个对象的类型。&lt;/p&gt;

&lt;h4 id=&quot;策略模式strategy&quot;&gt;策略模式(Strategy)&lt;/h4&gt;

&lt;p&gt;策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。&lt;/p&gt;

&lt;p&gt;代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额。&lt;/p&gt;

&lt;p&gt;没有使用策略模式的情况：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Price(personType, price) {
    //vip 5 折
    if (personType == 'vip') {
        return price * 0.5;
    } 
    else if (personType == 'old'){ //老客户 3 折
        return price * 0.3;
    } else {
        return price; //其他都全价
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;不足之处：不好的地方，当我有其他方面的折扣时，又或者我活动的折扣时经常变化的，这样就要不断的修改if..else里面的条件了。而且也违背了设计模式的一个原则：&lt;strong&gt;对修改关闭，对扩展开放的原则&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;使用策略模式之后：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 对于vip客户
function vipCustomer() {
    this.discount = 0.5;
}
 
vipCustomer.prototype.getPrice = function(price) {
　　return price * this.discount;
}
// 对于老客户
function oldCustomer() {
    this.discount = 0.3;
}
 
oldCustomer.prototype.getPrice = function(price) {
    return price * this.discount;
}
// 对于普通客户
function normalCustomer() {
    this.discount = 1;
}
 
normalCustomer.prototype.getPrice = function(price) {
    return price ;
}

// 上下文，对于客户端的使用
function Context() {
    this.name = '';
    this.strategy = null;
    this.price = 0;
}
 
Context.prototype.set = function(name, strategy, price) {
    this.name = name;
    this.strategy = strategy;
    this.price = price;
}
Context.prototype.getResult = function() {
    console.log(this.name + ' 的结账价为: ' + this.strategy.getPrice(this.price));
}

var context = new Context();
var vip = new vipCustomer();
context.set ('vip客户', vip, 200);
context.getResult();   // vip客户 的结账价为: 100

var old = new oldCustomer();
context.set ('老客户', old, 200);
context.getResult();  // 老客户 的结账价为: 60

var Price = new normalCustomer();
context.set ('普通客户', Price, 200);
context.getResult();  // 普通客户 的结账价为: 200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;装饰者模式decrator&quot;&gt;装饰者模式（decrator）&lt;/h4&gt;

&lt;p&gt;动态地给一个对象添加一些新的方法。就扩展功能而言，它比生成子类方式更为灵活。装饰者的运作过程是透明的，这就是说你可以用它包装其他对象，然后继续按之前使用那么对象的方法来使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var myText= {};
myText.Decorations={};
myText.Core=function(myString){
    this.show =function(){return myString;}
}
//第一次装饰，string后加？
myText.Decorations.addQuestuibMark =function(myString){
    this.show =function(){return myString.show()+'?';};
}
//第二次装饰，添加标签
myText.Decorations.makeItalic =function(myString){
    this.show =function(){return'&amp;lt;li&amp;gt;'+myString.show()+'&amp;lt;/li&amp;gt;'};
}
//得到myText.Core的实例
var theString =new myText.Core('this is a sample test String');
alert(theString.show());　　//output 'this is a sample test String'

//得到？装饰后的String
theString =new myText.Decorations.addQuestuibMark(theString);
alert(theString.show());　　//output 'this is a sample test String?'

//得到标签装饰后的String
theString =new myText.Decorations.makeItalic (theString);
alert(theString.show());　　//output '&amp;lt;li&amp;gt;this is a sample test String&amp;lt;/li&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从这个示例中可以看出，我们的目的是为了得到装饰过得String，这一切都可以不用事先知道组件对象的接口，也就是说我们只需要调用myString.show()，而其中具体的实现不用关心，甚至可以动态的实现。&lt;/p&gt;

&lt;p&gt;在为现有对象增添特性这方面，装饰者模式有极大的灵活性。如果需要为类增加特性或者方法，而从该类派生子类的解决办法并不实际的话，就应该使用装饰者模式。派生子类之所以会不实际最常见的原因是需要添加的特性或方法的数量要求使用大量子类。&lt;/p&gt;

&lt;h4 id=&quot;适配器模式adapter&quot;&gt;适配器模式（Adapter）&lt;/h4&gt;

&lt;p&gt;将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作，使用这种模式的对象又叫包装器，因为他们是在用一个新的接口包装另一个对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//一个参数为两个字符串的接口函数
var interface = function(str1, str2){
    ...
}
//现在我们想使用上面接口函数，但是参数是一个对象
var test = {
    str1 : '1',
    str2 : '2'
}
//适配器函数
var adapterMethod = function(obj){
    return interface(obj.str1, obj.str2);
}
//调用
adapterMethod(test);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;观察者模式observer&quot;&gt;观察者模式（Observer）&lt;/h4&gt;

&lt;p&gt;定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。典型的是事件监听器绑定。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id='test'&amp;gt;test&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
var fn1 = function(){
    ...
}
var fn2 = function(){
    ...
}
var test = document.getElementsById('test');
//绑定两个监听click事件
test.addElementListener('click', fn1, false);
test.addELementListener('click', fn2, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;门面模式facede&quot;&gt;门面模式（facede）&lt;/h4&gt;

&lt;p&gt;子系统中的一组接口提供一个一致的界面，门面模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。实际上就是把一组工具函数包装在一个对象里，对外的门面就是这个对象，&lt;strong&gt;门面模式是几乎所有JavaScript库的核心原则&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;优雅降级和渐进增强&lt;/p&gt;

&lt;p&gt;优雅降级：Web站点在所有新式浏览器中都能正常工作的前提下，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：border-shadow&lt;/p&gt;

&lt;p&gt;渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；&lt;/p&gt;

&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;

&lt;p&gt;Node的优缺点&lt;/p&gt;

&lt;p&gt;（优点) 因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
    因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
    此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，
    因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。&lt;/p&gt;

&lt;p&gt;（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，
    而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。&lt;/p&gt;

&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;

&lt;p&gt;前端性能优化的办法&lt;/p&gt;

&lt;p&gt;（1）减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。&lt;/p&gt;

&lt;p&gt;（2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数&lt;/p&gt;

&lt;p&gt;（3）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。&lt;/p&gt;

&lt;p&gt;（4）当需要设置的样式很多时设置className而不是直接操作style。&lt;/p&gt;

&lt;p&gt;（5）少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。&lt;/p&gt;

&lt;p&gt;（6）避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。&lt;/p&gt;

&lt;p&gt;（7）图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。&lt;/p&gt;

&lt;p&gt;（8）避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。&lt;/p&gt;

&lt;p&gt;对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。&lt;/p&gt;

&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;

&lt;p&gt;http状态码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200  OK         正常返回信息
201  Created    请求成功并且服务器创建了新的资源
202  Accepted   服务器已接受请求，但尚未处理
301  Moved Permanently  请求的网页已永久移动到新位置。
302  Found       临时性重定向。
303  See Other   临时性重定向，且总是使用 GET 请求新的 URI。
304  Not Modified 自从上次请求后，请求的网页未修改过。
400  Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401  Unauthorized 请求未授权。
403  Forbidden   禁止访问。
404  Not Found   找不到如何与 URI 相匹配的资源。
500  Internal Server Error  最常见的服务器端错误。
503  Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;

&lt;p&gt;一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;再输入url的时候，浏览器可能会做一些预处理，比如 Chrome 会根据历史统计来预估所输入字符对应的网站，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「www.baidu.com 」，因此就会在输入回车前就马上开始建立 TCP 链接甚至渲染了，还有很多其它很多优化策略&lt;/li&gt;
  &lt;li&gt;浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;&lt;/li&gt;
  &lt;li&gt;浏览器内核中会先查看缓存，然后调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;&lt;/li&gt;
  &lt;li&gt;进行DNS解析，使用UDP协议获取网址的IP地址;&lt;/li&gt;
  &lt;li&gt;设置 UA 等信息发出第二个GET请求，进行HTTP协议会话，客户端发送报头(请求报头);&lt;/li&gt;
  &lt;li&gt;进过运营商路由，主干网传输，进入到相应服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;&lt;/li&gt;
  &lt;li&gt;进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的处理过程;&lt;/li&gt;
  &lt;li&gt;处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回http状态码304，表示网页未修改过;&lt;/li&gt;
  &lt;li&gt;浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;&lt;/li&gt;
  &lt;li&gt;文档树建立，根据标记请求所需指定css、js等文件,同时设置cookie;&lt;/li&gt;
  &lt;li&gt;浏览器内核开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成，呈现给用户。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;7&quot;&gt;7&lt;/h3&gt;

&lt;p&gt;对称/非对称加密，公钥和私钥&lt;/p&gt;

&lt;p&gt;基本概念:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对称加密, 最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非对称加密， 非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;密钥对，在非对称加密技术中，有两种密钥，分为私钥和公钥，私钥是密钥对所有者持有，不可公布，公钥是密钥对持有者公布给他人的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;摘要，对需要传输的文本，做一个HASH计算，一般采用SHA1，SHA2来获得。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;签名，使用私钥对需要传输的文本的摘要进行加密，得到的密文即被称为该次传输过程的签名。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;签名验证，数据接收端，拿到传输文本，但是需要确认该文本是否就是发送发出的内容，中途是否曾经被篡改。因此拿自己持有的公钥对签名进行解密（密钥对中的一种密钥加密的数据必定能使用另一种密钥解密。），得到了文本的摘要，然后使用与发送方同样的HASH算法计算摘要值，再与解密得到的摘要做对比，发现二者完全一致，则说明文本没有被篡改过。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;证书中心（certificate authority，简称CA), CA用自己的私钥，对发送者公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate），发送时连同签名一起发送&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。而非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。&lt;/p&gt;

&lt;p&gt;以Alice和银行之间的通信为例，这同时也是https协议的简略过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Alice向Bank请求公钥&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bank网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给Alice的浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Alice的浏览器获得证书后验证合法性，客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表，客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若证书合法，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密，这就是对称加密的秘钥。接下来会进行握手验证，使用约定好的HASH算法加密一段握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的对称加密的秘钥（使用公钥加密过的）+ 加密的握手消息发送给Bank。 若不合法则发出警告。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bank使用私钥解密得到对称秘钥，使用秘钥解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 然后使用密码加密一段握手消息，发送给浏览器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，Alice和Bank使用对称秘钥互相传输数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/jsbase4/Alice&amp;amp;Bank.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTPS一般使用的加密与HASH算法如下：&lt;/p&gt;

&lt;p&gt;非对称加密算法：RSA，DSA/DSS&lt;/p&gt;

&lt;p&gt;对称加密算法：AES，RC4，3DES&lt;/p&gt;

&lt;p&gt;HASH算法：MD5，SHA1，SHA256&lt;/p&gt;

&lt;h3 id=&quot;8&quot;&gt;8&lt;/h3&gt;

&lt;p&gt;XML和JSON的区别？&lt;/p&gt;

&lt;p&gt;(1).数据体积方面。&lt;/p&gt;

&lt;p&gt;JSON相对于XML来讲，数据的体积小，传递的速度更快些。&lt;/p&gt;

&lt;p&gt;(2).数据交互方面。&lt;/p&gt;

&lt;p&gt;JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。&lt;/p&gt;

&lt;p&gt;(3).数据描述方面。&lt;/p&gt;

&lt;p&gt;JSON对数据的描述性比XML较差。&lt;/p&gt;

&lt;p&gt;(4).传输速度方面。&lt;/p&gt;

&lt;p&gt;JSON的速度要远远快于XML。&lt;/p&gt;

&lt;h3 id=&quot;9&quot;&gt;9&lt;/h3&gt;

&lt;p&gt;JavaScript垃圾回收机制&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;标记清除： 为所有进入内存的变量加上标记，除去环境中的变量和被环境中变量引用的变量（闭包）后，剩下被标记的变量就是要被清除的变量，到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;引用计数： 跟踪每个值被引用的次数，当声明一个变量并将引用类型的值赋给此变量，则引用+1，当次变量引用的值改变时，则引用-1，当引用为0时，代表没有变量可以引用这个值，可以进行回收。这种机制存在一个问题，当变量存在循环引用的情况会造成内存泄漏。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;什么时候进行：&lt;/p&gt;

&lt;p&gt;垃圾回收周期性进行，一般都是动态进行的，如垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，如果回收的内存高于85%，说明大部分内存早就该清理了，这时候把触发条件置回。&lt;/p&gt;

&lt;h3 id=&quot;10&quot;&gt;10&lt;/h3&gt;

&lt;p&gt;Web安全及防护原理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SQL注入&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过把SQL插入Web表单欺骗服务器执行恶意SQL&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不要相信用户输入，利用正则等方式对输入的合法性进行判断，格式，长度，特殊字符等。&lt;/li&gt;
  &lt;li&gt;不要使用动态拼装SQL，使用参数化的SQL或存储过程进行数据库操作&lt;/li&gt;
  &lt;li&gt;不要使用管理员权限连接数据库，应为每个应用分配单独的权限有限的数据库连接&lt;/li&gt;
  &lt;li&gt;不要明文存放敏感信息，加密或Hash&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;XSS(cross-site scripting)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;攻击者向Web页面中恶意插入html标签或Js代码，比如攻击者在页面中插入一个看似安全的链接，用户点击后窃取cookie和用户输入信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于用户输入要仔细检查长度以及’&amp;lt;’’&amp;gt;’等特殊符号，任何内容写到页面之前都要encode，避免在页面显示时出现html tag，做到这一步能避免超过半数的XSS攻击&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;避免在cookie中直接暴露用户隐私&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;CSRF（Cross-site request forgery），跨站请求伪造&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全&lt;/p&gt;

&lt;p&gt;要完成一次CSRF攻击，受害者必须依次完成两个步骤：&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;登录受信任网站A，并在本地生成Cookie。&lt;/li&gt;
  &lt;li&gt;在不登出A的情况下，访问危险网站B。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;防御：&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数&lt;/li&gt;
  &lt;li&gt;通过验证码的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;10-1&quot;&gt;10&lt;/h3&gt;

&lt;p&gt;ES6&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;let和const，let加入块级作用域&lt;/li&gt;
  &lt;li&gt;模板字符串，为JavaScript提供了简单的字符串插编辑功能&lt;/li&gt;
  &lt;li&gt;Symbol，独一无二变量&lt;/li&gt;
  &lt;li&gt;箭头函数&lt;/li&gt;
  &lt;li&gt;Set和Map&lt;/li&gt;
  &lt;li&gt;原生Promise&lt;/li&gt;
  &lt;li&gt;Module Import，Export&lt;/li&gt;
  &lt;li&gt;Class&lt;/li&gt;
  &lt;li&gt;interator和for of&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;11&quot;&gt;11&lt;/h3&gt;

&lt;p&gt;for in和for of&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;for…in循环出的是key，for…of循环出的是value&lt;/li&gt;
  &lt;li&gt;for…of是ES6对于forEach的改善，for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。for of只可以循环可迭代对象的可迭代属性，不可迭代属性在循环中被忽略了（优点1）；可以与break、continue和return配合使用。（优点2）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结论：推荐在循环对象属性的时候，使用for…in,在遍历数组的时候的时候使用for…of。&lt;/p&gt;

&lt;h3 id=&quot;12&quot;&gt;12&lt;/h3&gt;

&lt;p&gt;Cookie和Session&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;session 在服务器端，cookie 在客户端（浏览器）&lt;/li&gt;
  &lt;li&gt;session 默认被存在在服务器的一个文件里（不是内存）&lt;/li&gt;
  &lt;li&gt;session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）&lt;/li&gt;
  &lt;li&gt;session 可以放在 文件、数据库、或内存中都可以。&lt;/li&gt;
  &lt;li&gt;用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id&lt;/li&gt;
  &lt;li&gt;cookie是不安全的，一些网络攻击如XSS和CSRF可以获取cookie或进行cookie欺骗，所以重要信息放在session里，必要放在cookie里要枷锁&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;13&quot;&gt;13&lt;/h2&gt;

&lt;p&gt;javascript继承的6种方法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;原型链继承: 将父类的实例作为子类的原型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;借用构造函数继承: 使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实例继承：为父类实例添加新特性，作为子类实例返回&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拷贝继承&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
Cat.prototype = new Animal();

//组合继承也是需要修复构造函数指向的。
Cat.prototype.constructor = Cat;

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法&lt;/li&gt;
  &lt;li&gt;既是子类的实例，也是父类的实例&lt;/li&gt;
  &lt;li&gt;不存在引用属性共享问题
4.5可传参&lt;/li&gt;
  &lt;li&gt;函数可复用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）&lt;/p&gt;

&lt;p&gt;6.寄生继承&lt;/p&gt;

&lt;p&gt;核心：与原型链继承相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。寄生式继承解决了组合式继承中两次调用父类的情况，寄生继承不用实例化父类，直接实例化一个临时副本实现相同的原型链继承&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
(function(){
  // 创建一个没有实例方法的类
  var Super = function(){};
  Super.prototype = Animal.prototype;
  //将实例作为子类的原型
  Cat.prototype = new Super();
})();

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); //true

Cat.prototype.constructor = Cat; // 需要修复下构造函数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-1&quot;&gt;13&lt;/h3&gt;

&lt;p&gt;MVC和MVVM的理解&lt;/p&gt;

&lt;p&gt;MVC&lt;/p&gt;

&lt;p&gt;View 传送指令到 Controller, Controller 完成业务逻辑后，要求 Model 改变状态, Model 将新的数据发送到 View，用户得到反馈, 所有通信都是单向的。&lt;/p&gt;

&lt;p&gt;MVVM&lt;/p&gt;

&lt;p&gt;典型的Angular，它采用双向绑定（data-binding）：View的变动，自动反映在ViewModel，反之亦然。组成部分Model、View、ViewModel&lt;/p&gt;

&lt;p&gt;View：UI界面&lt;/p&gt;

&lt;p&gt;ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；&lt;/p&gt;

&lt;p&gt;Model：数据访问层&lt;/p&gt;

&lt;h3 id=&quot;14&quot;&gt;14&lt;/h3&gt;

&lt;p&gt;事件代理&lt;/p&gt;

&lt;p&gt;事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能，提高代码可读性，对于动态化的页面（如li、span会新增和删除），不用频繁的绑定事件，减少了内存泄露的概率。&lt;/p&gt;

&lt;h3 id=&quot;15&quot;&gt;15&lt;/h3&gt;

&lt;p&gt;304缓存原理&lt;/p&gt;

&lt;p&gt;客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体&lt;/p&gt;

</description>
        <pubDate>Mon, 04 Dec 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/12/04/JaveScript-Note(4)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/12/04/JaveScript-Note(4)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Note(3)</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;同步与异步&lt;/p&gt;

&lt;p&gt;同步的概念是来自OS中同步的概念：不同的进程为了完成某项任务在执行先后顺序上进行协作，通过唤醒、阻塞等方式调节。&lt;/p&gt;

&lt;p&gt;对于Web而言：&lt;br /&gt;
同步: 访问服务器，服务器回应，页面刷新，用户操作，整个过程是串行的方式进行的，影响用户操作&lt;br /&gt;
异步: 访问服务器，用户继续操作，服务器回应，页面更新，用户操作，整个过程不发生整页刷新，不影响用户操作&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;跨域问题&lt;/p&gt;

&lt;h4 id=&quot;同源策略&quot;&gt;同源策略&lt;/h4&gt;

&lt;p&gt;同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。&lt;/p&gt;

&lt;h4 id=&quot;jsonp&quot;&gt;JSONP&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;由于同源政策的存在，Ajax直接请求普通文件存在跨域无权限访问的问题，无论是静态页面、动态网页、web服务，只要是跨域请求，一律不准；另一方面，通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，这些拥有”src”这个属性的标签都拥有跨域的能力，比如&amp;lt;script&amp;gt;、&amp;lt;img&amp;gt;、&amp;lt;iframe&amp;gt;等标签。&lt;/li&gt;
  &lt;li&gt;JSONP正是利用这一点，web客户端通过与调用脚本一模一样的方式来调用跨域服务器上的资源，服务器端则动态生成JSON，把客户端需要的数据装入进去。&lt;/li&gt;
  &lt;li&gt;其缺点是只能实现get一种请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;script&amp;gt;
 //原生实现
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参并指定回调执行函数为onBack
    script.src = 'http://www.domain2.com:8080/login?user=admin&amp;amp;callback=onBack';
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
 &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;postmessage&quot;&gt;postMessage&lt;/h4&gt;

&lt;p&gt;postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;页面和其打开的新窗口的数据传递&lt;/li&gt;
  &lt;li&gt;多窗口之间消息传递&lt;/li&gt;
  &lt;li&gt;页面与嵌套的iframe消息传递&lt;/li&gt;
  &lt;li&gt;上面三个场景的跨域数据传递&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用法：postMessage(data,origin)方法接受两个参数&lt;/p&gt;

&lt;p&gt;data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。&lt;br /&gt;
origin： 协议+主机+端口号，也可以设置为”*“，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/”。&lt;/p&gt;

&lt;p&gt;1.）a.html：(http://www.domain1.com/a.html)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;script&amp;gt;       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };

    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---&amp;gt; ' + e.data);
    }, false);
&amp;lt;/script
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.）b.html：(http://www.domain2.com/b.html)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---&amp;gt; ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;corscross-orign-resource-share跨域资源共享&quot;&gt;CORS(Cross orign resource share)跨域资源共享&lt;/h4&gt;

&lt;p&gt;服务器端设置Access-Control-Allow-Origin,前端无须设置&lt;/p&gt;

&lt;p&gt;“*”号表示允许任何域向我们的服务端提交请求：Access-Control-Allow-Origin：*&lt;/p&gt;

&lt;p&gt;也可以设置指定的域名，如域名 http://www.test2.com ，那么就允许来自这个域名的请求：Access-Control-Allow-Origin：http://www.test2.com&lt;/p&gt;

&lt;p&gt;若要带cookie请求：前后端都需要设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200) {
        alert(xhr.responseText);
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;

&lt;p&gt;页面编码和被请求的资源编码如果不一致如何处理？&lt;/p&gt;

&lt;p&gt;设置charset&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;http://www.xxx.com/test.js&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;//todo&lt;/p&gt;

&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;

&lt;p&gt;前端模块化加载&lt;/p&gt;

&lt;p&gt;知识点1：AMD(Asynchronous Module Definition)/CMD(Common Module Definition)/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs.&lt;/p&gt;

&lt;p&gt;知识点2：CommonJs主要针对服务端，AMD/CMD主要针对浏览器端，所以最容易混淆的是AMD/CMD。（顺便提一下，针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行。这里如果有其他后端语言，如java，经验的‘玩家’应该更容易理解。而浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好。）&lt;/p&gt;

&lt;p&gt;知识点3 : AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。&lt;/p&gt;

&lt;p&gt;知识点4：AMD/CMD的优缺点.一个的优点就是另一个的缺点， 可以对照浏览。&lt;/p&gt;

&lt;p&gt;AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。&lt;br /&gt;
AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。&lt;/p&gt;

&lt;p&gt;CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。&lt;br /&gt;
CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。&lt;/p&gt;

&lt;p&gt;知识点5：如何使用？CommonJs的话，因为nodeJs就是它的实现，所以使用node就行，也不用引入其他包。AMD则是通过&amp;lt;script&amp;gt;标签引入RequireJs，CMD则是引入SeaJs。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // CMD
 define(function(require, exports, module) {
     var a = require('./a')
     a.doSomething()
     // 此处略去 100 行
     var b = require('./b') // 依赖可以就近书写
     b.doSomething()
     // ...
 })

 // AMD 默认推荐
 define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
     a.doSomething()
     // 此处略去 100 行
     b.doSomething()
     // ...
 })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;

&lt;p&gt;DOM操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//创建
createElement() //创建元素
createDocumentFragment()  //创建DOM片段
createTextNode() //创建文本节点

//操作
appendChild() //添加
removeChild() //删除
replaceChild() //替换
insertbefore() //在已有节点前插入新节点

//查找
getElementsById()
getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
getElementsByTag()
getElementsByClass()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;

&lt;p&gt;call和apply&lt;/p&gt;

&lt;p&gt;foo.call(this, arg1,arg2,arg3) == foo.apply(this, arguments)==this.foo(arg1, arg2, arg3)&lt;/p&gt;

&lt;h3 id=&quot;7&quot;&gt;7&lt;/h3&gt;

&lt;p&gt;内存泄漏&lt;/p&gt;

&lt;p&gt;内存泄漏时指一块被分配的内存既不能使用也不能回收。在JavaScipt出现主要有两种情况:&lt;/p&gt;

&lt;p&gt;1.循环引用。含有DOM对象的循环引用将导致大部分当前主流浏览器内存泄露。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//a,b循环引用
var a = new Object;
var b = new Object;
a.r = b;
b.r = a;

//a循环引用自己
var a = new Object;
a.r = a;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.闭包。&lt;/p&gt;

&lt;p&gt;闭包可以导致内存泄漏是因为内部方法保持一个对外部方法变量的引用，所以尽管方法返回了内部方法还可以继续访问在外部方法中定义的私有变量，所以这些变量被一直保存在内存中。&lt;/p&gt;

&lt;p&gt;3.setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏&lt;/p&gt;

&lt;h3 id=&quot;8&quot;&gt;8&lt;/h3&gt;

&lt;p&gt;如何判断当前脚本运行在浏览器还是node环境中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this === window ? 'browser' : 'node'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;9&quot;&gt;9&lt;/h3&gt;

&lt;p&gt;把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？&lt;/p&gt;

&lt;p&gt;放在body的封闭之前，将会阻塞其他资源的加载，放在body封闭之后，不会影响body内元素的加载&lt;/p&gt;

&lt;h3 id=&quot;10&quot;&gt;10&lt;/h3&gt;

&lt;p&gt;给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？&lt;/p&gt;

&lt;p&gt;绑定几个事件就执行几次，执行优先级:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;父元素的捕获事件&lt;/li&gt;
  &lt;li&gt;目标元素的顺序事件，无视捕获还是冒泡&lt;/li&gt;
  &lt;li&gt;父元素的冒泡事件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class='d1'&amp;gt;
    &amp;lt;div class='d2'&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script type='text/javascript'&amp;gt;
var d1 = document.getElementsByClass('d1');
var d2 = document.getElementsByClass('d2');
     
//父级绑定click事件冒泡
d1.addEventListener('click', function(){ console.log('parent bubble') }, false);

//子级绑定click事件冒泡
d2.addEventListener('click', function(){ console.log('child bubble') }, false);

//子级绑定click事件捕获
d2.addEventListener('click', function(){ console.log('child capture') }, true);

//父级绑定click事件捕获
d1.addEventListener('click', function(){ console.log('parent capture') }, true);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;console:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;parent capture
child bubble
child capture
parent bubble
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;11&quot;&gt;11&lt;/h3&gt;

&lt;p&gt;==, ===, Object.is()区别&lt;/p&gt;

&lt;p&gt;==会进行类型转换，===不会，Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Nov 2017 19:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/29/JavaScript-Note(3)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/29/JavaScript-Note(3)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScrip Note(2)</title>
        <description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;

&lt;p&gt;This的理解&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;this总是指向函数的直接调用者（而非间接调用者）,即此次调用的所有者&lt;/li&gt;
  &lt;li&gt;如果有new对象，this指向new出来的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;Eval&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Eval将传入的字符串当做JS代码执行, 应避免在不必要的情况下使用
    &lt;ul&gt;
      &lt;li&gt;运行Eval存在风险，有可能运行的是恶意代码&lt;/li&gt;
      &lt;li&gt;运行效率差，因为会调用JS解析器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;

&lt;p&gt;window对象和document对象&lt;/p&gt;

&lt;p&gt;window对象是浏览器打开的窗口，顶层对象，document是window对象的一个属性，HTML文档对象的一个&lt;strong&gt;只读引用&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;

&lt;p&gt;IE和firefox事件机制&lt;/p&gt;

&lt;p&gt;IE是事件冒泡，firefox同时支持事件冒泡和捕获&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;事件捕获: 越高层的元素越早接收到事件，由上到下&lt;/li&gt;
  &lt;li&gt;事件冒泡: 越低层的元素越早接收到时间，由下到上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;阻止冒泡事件的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;xxx.click = function(e){
	e.stopPropagation();
	e.cancelBubble = true;//旧IE需要
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;

&lt;p&gt;new的过程&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建空对象；
    &lt;ul&gt;
      &lt;li&gt;var obj = {};&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将创建出对象的原型链引用指向所要构造函数的原型；
    &lt;ul&gt;
      &lt;li&gt;obj.__proto__ = ClassA.prototype;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;调用构造函数，this指向新实例对象：
    &lt;ul&gt;
      &lt;li&gt;ClassA.call(obj);　　//{}.构造函数();&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将初始化完毕的新对象地址，保存到等号左边的变量中&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;

&lt;p&gt;JS中不会查找原型的函数&lt;/p&gt;

&lt;p&gt;hasOwnProperty判断对象中是否有指定名称的属性，object.hasOwnProperty(proName)，proName是属性名称的&lt;strong&gt;字符串值&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;7&quot;&gt;7&lt;/h3&gt;

&lt;p&gt;JSON的了解&lt;/p&gt;

&lt;p&gt;JSON（JavaScript Object Notation）是一种&lt;strong&gt;轻量级的数据交换格式&lt;/strong&gt;，是基于JavaScript的一个子集，具有&lt;strong&gt;数据格式简单，易于读写且占用带宽小&lt;/strong&gt;的优点。&lt;/p&gt;

&lt;p&gt;字符串转对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;JSON.parse(str);
str.parseJSON(str);
eval('(' + str + ')')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象转字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;JSON.stringify(obj);
obj.toJSONString(str);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8&quot;&gt;8&lt;/h3&gt;

&lt;p&gt;Ajax&lt;/p&gt;

&lt;p&gt;Asynchronous JavaScript and Xml, 异步传输+JS+xml，异步的含义是在向服务器发送请求后，不必等待响应，可以先做其他的事，等相应返回可以根据设定的callback函数进行操作，于此同时，网页不会发生整页刷新，提高了效率和用户体验。&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建XMLHttpRequest对象&lt;/li&gt;
  &lt;li&gt;设置响应HTTP请求状态变化的函数&lt;/li&gt;
  &lt;li&gt;指定该对象的的方法、URL及验证信息&lt;/li&gt;
  &lt;li&gt;发送HTTP请求&lt;/li&gt;
  &lt;li&gt;获取异步调用返回的数据&lt;/li&gt;
  &lt;li&gt;使用JavaScript和DOM实现局部刷新&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button id=&quot;ajaxButton&quot; type =&quot;button&quot;&amp;gt;Make Ajax request&amp;lt;/button&amp;gt;

&amp;lt;script&amp;gt;
var httpRequest;
document.getElementbyId('ajaxButton').addEventListener(&quot;click&quot;, sendRequest);

function sendRequest(){
	httpRequest = new XMLHttpRequest(); //1

	if(httpRequest){
		alert('Cannot creat XMLHttpRequest');
		return;
	}

	httpRequest.onreadystatechange = stateFunction;//2
	httpRequest.open('GET', 'test.html');//3
	httpRequest.send();//4
}

function stateFunction(){
	if(httpRequest.readyState === XMLHttpRequet.Done){
		if(httpRequest.state === 200){
			alert(httpRequest.responseText);//5
			//... 6
		}
		else{
			alert('The request has some problem');
		}
	}
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;9&quot;&gt;9&lt;/h3&gt;

&lt;p&gt;JS延迟加载方式&lt;/p&gt;

&lt;p&gt;JS延迟加载就是在页面加载完成后再加载JS文件，有助于提高页面加载速度，提高用户体验。&lt;/p&gt;

&lt;h4 id=&quot;使用defer或async属性&quot;&gt;使用defer或async属性&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;test1.js&quot; defer=&quot;defer&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;test2.js&quot; async&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;只适用于外部脚本，缺点是不能保证脚本会按顺序执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当浏览器碰到 script 脚本的时候：&lt;/p&gt;

&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。&lt;/p&gt;

&lt;script async=&quot;&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。&lt;/p&gt;

&lt;script defer=&quot;&quot; src=&quot;myscript.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。&lt;/p&gt;

&lt;p&gt;然后从实用角度来说呢，首先把所有脚本都丢到 &amp;lt;/body&amp;gt; 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lrun1124.github.io/img/jsbase2/defer&amp;amp;async.jpg&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;动态dom操作&quot;&gt;动态DOM操作&lt;/h4&gt;

&lt;p&gt;即利用动态DOM操作按需插入JS文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//延迟1000ms加载new.js
window.onload = function(){
	setTimeout(function(){
		var head = document.getElementByTagName('head')[0];
		var js = document.createElement('Script');
		js.type = 'text/javascript';
		js.src = 'new.js';
		head.appendChlid(js); 
	},1000);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;分组最后加载js&quot;&gt;分组最后加载JS&lt;/h4&gt;

&lt;p&gt;JS的引入如果放在head中，则页面加载前JS就会被加载，如果放在body中，则会按顺序加载，所以可以将JS分组，将加载过程中不需要的JS放在页面的底部，&amp;lt;/body&amp;gt;标签之前，然而这种方法偶尔会收到Google页面速度测试工具的“延迟加载javascript”警告，Google提供了一套推荐方案：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//这些代码应被放置在&amp;lt;/body&amp;gt;标签前(接近HTML文件底部)
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    function downloadJSAtOnload() {
        var element = document.createElement(&quot;script&quot;);
        element.src = &quot;defer.js&quot;;
        document.body.appendChild(element);
    }
    if (window.addEventListener)
        window.addEventListener(&quot;load&quot;, downloadJSAtOnload, false);
    else if (window.attachEvent)
        window.attachEvent(&quot;onload&quot;, downloadJSAtOnload);
    else window.onload = downloadJSAtOnload;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码意思是等到整个文档加载完后，再加载外部文件“defer.js”。&lt;/p&gt;

&lt;p&gt;使用此段代码的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;复制上面代码；&lt;/li&gt;
  &lt;li&gt;粘贴代码放置在&amp;lt;/body&amp;gt;标签前 (靠近HTML文件底部)；&lt;/li&gt;
  &lt;li&gt;修改“defer.js”为外部JS文件名；&lt;/li&gt;
  &lt;li&gt;确保文件路径是正确的。例如：如果仅输入“defer.js”，那么“defer.js”文件一定与HTML文件在同一文件夹下。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;注意：这段代码直到文档加载完才会加载指定的外部js文件。因此，不应该把那些页面正常加载需要依赖的javascript代码放在这里。而应该将JavaScript代码分成两组。&lt;strong&gt;一组是因页面需要而立即加载的javascript代码，另外一组是在页面加载后进行操作的javascript代码(例如添加click事件或其他东西)&lt;/strong&gt;。这些需等到页面加载后再执行的JavaScript代码，应放在一个外部文件，然后再引进来。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;10&quot;&gt;10&lt;/h3&gt;

&lt;p&gt;Ajax缓存问题&lt;/p&gt;

&lt;p&gt;Ajax能提高页面载入的速度主要的原因是通过Ajax减少了重复数据的载入，也就是说在载入数据的同时将数据缓存到内存中，一旦数据被加载其中，只要我们没有刷新页面，这些数据就会一直被缓存在内存中，当我们提交的URL与历史的URL一致时，就不需要提交给服务器，也就是不需要从服务器上面去获取数据，虽然这样降低了服务器的负载提高了用户的体验，但是我们不能获取最新的数据。为了保证我们读取的信息都是最新的，我们就需要禁止缓存功能。&lt;/p&gt;

&lt;p&gt;解决方案有如下几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。&lt;/li&gt;
  &lt;li&gt;在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。&lt;/li&gt;
  &lt;li&gt;在URL后面加上一个随机数： “fresh=” + Math.random();。&lt;/li&gt;
  &lt;li&gt;在URL后面加上时间戳：”nowtime=” + new Date().getTime();。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;11&quot;&gt;11&lt;/h3&gt;

&lt;p&gt;GET和POST的区别，何时使用POST？&lt;/p&gt;

&lt;p&gt;GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符&lt;/p&gt;

&lt;p&gt;POST：一般用于修改服务器上的资源，对所发送的信息没有限制。&lt;/p&gt;

&lt;p&gt;GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，&lt;/p&gt;

&lt;p&gt;也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。&lt;/p&gt;

&lt;p&gt;然而，在以下情况中，请使用 POST 请求：&lt;/p&gt;

&lt;p&gt;无法使用缓存文件（更新服务器上的文件或数据库）&lt;/p&gt;

&lt;p&gt;向服务器发送大量数据（POST 没有数据量限制）&lt;/p&gt;

&lt;p&gt;发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠&lt;/p&gt;
</description>
        <pubDate>Fri, 24 Nov 2017 03:00:00 +0800</pubDate>
        <link>http://localhost:4000/lrun1124.github.io/2017/11/24/JavaScript-Note(2)/</link>
        <guid isPermaLink="true">http://localhost:4000/lrun1124.github.io/2017/11/24/JavaScript-Note(2)/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
  </channel>
</rss>

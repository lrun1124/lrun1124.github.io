---
layout:     post
title:      "浏览器，渲染引擎，JS内核（V8)"
subtitle:   ""
date:       2019-10-21 12:00:00
author:     "Run"
header-img: "img/ArrayUnique-bg.jpg"
tags:
    - JavaScript
---

> “Move on. ”

### 常见的浏览器内核有哪些？

  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>
  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>
  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br>
  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]

### JS内核（V8）

#### 浏览器架构

<img src="http://lrun1124.github.io/img/browser/structure.png"/>

1. User Interface 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
1. Browser engine 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。
1. Render engine 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
1. Networking 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
1. JavaScript 解释器。用于解析和执行 JavaScript 代码。
1. 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

#### 渲染引擎 Render engine
1. GUI渲染线程 (GUI render thread) : 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
1. JS引擎线程(V8)（JS thread） : 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）JS引擎线程负责解析Javascript脚本，运行代码。JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
1. 事件触发线程 : 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中，当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
1. 定时触发器线程。setInterval与setTimeout所在线程，浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）。因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
1. 异步http请求线程。 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？
所以，后来HTML5中支持了Web Worker。

MDN的官方解释是：
Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window因此，使用window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误这样理解下：

创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）
所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect!

而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。
WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享
所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。

SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用

所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。

看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程

#### 流程

<img src="http://lrun1124.github.io/img/browser/browser_workflow.png"/>

1. browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程
2. Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染
3. 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染, 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）
4. 最后Render进程将结果传递给Browser进程
5. Browser进程接收到结果并将结果绘制出来

#### 渲染进程处理html（webkit为例）

<img src="http://lrun1124.github.io/img/browser/webkit_workflow.png"/>

开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将转交给Renderer进程- 渲染大概可以划分成以下几个步骤：

1. 解析html建立dom树
1. 解析css构建CSSOM 树（Recaculate Style）
1. 合并 DOM 树与 CSSOM 树为 Render 树
1. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
1. 绘制render树（paint），绘制页面像素信息
1. 浏览器会将各层的信息发送给GPU，GPU会将各层复合图层化（composite），显示在屏幕上。
1. 渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了

其中布局（Layout）环节主要负责各元素尺寸、位置的计算，绘制（Paint）环节则是绘制页面像素信息，合成（Composite）环节是多个复合层的合成，最终合成的页面被用户看到。

需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。

1. 当 `DOMContentLoaded` 事件触发时，仅当DOM加载完成，不包括样式表，图片。(譬如如果有async加载的脚本就不一定完成)
1. 当 `onload` 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。

- css加载是否会阻塞dom树渲染？

这里说的是头部引入css的情况
首先，我们都知道：css是由单独的下载线程异步下载的。

然后再说下几个现象：

css加载不会阻塞DOM树解析（异步加载时DOM照常构建）, 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）。 这可能也是浏览器的一种优化机制。因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞render树渲染的话，那么当css加载完之后，render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。

解析的过程可以分成两个子过程：词法分析和语法分析。

#### DOM Tree

<img src="http://lrun1124.github.io/img/browser/domtree.png"/>

浏览器构建 DOM 树可以简单的总结为以下几步：
1. 转码（Bytes ->Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串
1. Tokens 化（Characters ->Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则
1. 构建 Nodes（Tokens ->Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同
1. 构建 DOM 树（Nodes ->DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系

#### CSSOM Tree

CSSOM 树的构建其实是一个 样式的重新计算 的过程，为什么是重新计算呢？

用户代理（即浏览器）本身有一套内置样式表，所以我们最终的 CSSOM 树其实是用户代理样式与页面所有样式的重新计算。
所以在 Chrome 浏览器开发者工具的 Timeline 面板下，CSSOM 树的构建对应的是 Recalculate Style 阶段
与 DOM 树的构建过程相似，CSSOM 的构建也要经历以下过程
<img src="http://lrun1124.github.io/img/browser/cssom1.png"/>
<img src="http://lrun1124.github.io/img/browser/cssom2.png"/>

#### Render Tree

<img src="http://lrun1124.github.io/img/browser/rendertree.png"/>

DOM 树与 CSSOM 树融合成渲染树
渲染树只包括渲染页面需要的节点
排除 \<script> \<meta> 等功能化、非视觉节点排除 display: none 的节点







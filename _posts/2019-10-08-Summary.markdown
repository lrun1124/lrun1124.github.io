---
layout:     post
title:      "Summary"
subtitle:   ""
date:       2019-10-16 12:00:00
author:     "Run"
header-img: "img/ArrayUnique-bg.jpg"
tags:
    - JavaScript
---

> “Move on. ”
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents** 

- [JS](#js)
  - [JS基本数据类型及存储结构，内置对象](#js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1)
  - [`null`, `undefined`区别, 未声明变量](#null-undefined%E5%8C%BA%E5%88%AB-%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F)
  - [JavaScript是采用值传递还是引用传递的，并解释一下原理](#javascript%E6%98%AF%E9%87%87%E7%94%A8%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%B9%B6%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%8E%9F%E7%90%86)
  - [JS原型，原型链， 原型继承（prototypal inheritance）的工作原理](#js%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BFprototypal-inheritance%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
  - [JS作用域，作用域链](#js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE)
  - [`闭包（closure）`，为什么使用闭包](#%E9%97%AD%E5%8C%85closure%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85)
  - [请简述`JavaScript`中的`this`。](#%E8%AF%B7%E7%AE%80%E8%BF%B0javascript%E4%B8%AD%E7%9A%84this)
  - [`New`的过程](#new%E7%9A%84%E8%BF%87%E7%A8%8B)
  - [不会查找原型的函数](#%E4%B8%8D%E4%BC%9A%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0)
  - [for in和for of](#for-in%E5%92%8Cfor-of)
  - [Ajax流程，手动写，Ajax缓存](#ajax%E6%B5%81%E7%A8%8B%E6%89%8B%E5%8A%A8%E5%86%99ajax%E7%BC%93%E5%AD%98)
  - [把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？](#%E6%8A%8A-script-%E6%A0%87%E7%AD%BE-%E6%94%BE%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9C%80%E5%BA%95%E9%83%A8%E7%9A%84body%E5%B0%81%E9%97%AD%E4%B9%8B%E5%89%8D-%E5%92%8C%E5%B0%81%E9%97%AD%E4%B9%8B%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)
  - [延迟加载，defer，async，动态dom，分组加载](#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDdeferasync%E5%8A%A8%E6%80%81dom%E5%88%86%E7%BB%84%E5%8A%A0%E8%BD%BD)
    - [使用defer或async属性](#%E4%BD%BF%E7%94%A8defer%E6%88%96async%E5%B1%9E%E6%80%A7)
    - [动态DOM操作](#%E5%8A%A8%E6%80%81dom%E6%93%8D%E4%BD%9C)
    - [分组最后加载JS](#%E5%88%86%E7%BB%84%E6%9C%80%E5%90%8E%E5%8A%A0%E8%BD%BDjs)
  - [get和post](#get%E5%92%8Cpost)
  - [同步和异步](#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5)
  - [前端模块化，AMD/CMD/CommonJS](#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96amdcmdcommonjs)
  - [内存泄漏](#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)
  - [==, ===, Object.is()区别](#--objectis%E5%8C%BA%E5%88%AB)
  - [前端设计模式，单例，单体，工厂，策略，装饰者，适配器，观察者，门面](#%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E5%8D%95%E4%BD%93%E5%B7%A5%E5%8E%82%E7%AD%96%E7%95%A5%E8%A3%85%E9%A5%B0%E8%80%85%E9%80%82%E9%85%8D%E5%99%A8%E8%A7%82%E5%AF%9F%E8%80%85%E9%97%A8%E9%9D%A2)
    - [单体模式(Singleton)](#%E5%8D%95%E4%BD%93%E6%A8%A1%E5%BC%8Fsingleton)
    - [单例模式(Single)](#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fsingle)
    - [工厂模式(Factory)](#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8Ffactory)
    - [策略模式(Strategy)](#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8Fstrategy)
    - [装饰者模式（decrator）](#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8Fdecrator)
    - [适配器模式（Adapter）](#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8Fadapter)
    - [观察者模式（Observer）](#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8Fobserver)
    - [门面模式（facede）](#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8Ffacede)
  - [优雅降级和渐进增强](#%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA)
  - [Node的优缺点](#node%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9)
  - [GC机制，v8 GC机制](#gc%E6%9C%BA%E5%88%B6v8-gc%E6%9C%BA%E5%88%B6)
    - [引用计数](#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0)
    - [V8机制](#v8%E6%9C%BA%E5%88%B6)
      - [全停顿](#%E5%85%A8%E5%81%9C%E9%A1%BF)
      - [新生代](#%E6%96%B0%E7%94%9F%E4%BB%A3)
      - [老生带](#%E8%80%81%E7%94%9F%E5%B8%A6)
      - [Incremental Marking（增量标记）](#incremental-marking%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0)
  - [Cookie和Session](#cookie%E5%92%8Csession)
  - [cookie, loaclStorage, sessionStorage](#cookie-loaclstorage-sessionstorage)
  - [javascript继承的6种方法](#javascript%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95)
  - [一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？](#%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%88%90%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88)
  - [JSON的了解](#json%E7%9A%84%E4%BA%86%E8%A7%A3)
  - [XML和JSON](#xml%E5%92%8Cjson)
  - [MVC和MVVM的理解](#mvc%E5%92%8Cmvvm%E7%9A%84%E7%90%86%E8%A7%A3)
  - [forEach循环和.map()循环的主要区别，它们分别在什么情况下使用？](#foreach%E5%BE%AA%E7%8E%AF%E5%92%8Cmap%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E5%AE%83%E4%BB%AC%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8)
  - [宿主对象（host objects）和原生对象（native objects）的区别是什么？](#%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1host-objects%E5%92%8C%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1native-objects%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)
  - [下列语句有什么区别：function Person(){}、var person = Person()和var person = new Person()？](#%E4%B8%8B%E5%88%97%E8%AF%AD%E5%8F%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%ABfunction-personvar-person--person%E5%92%8Cvar-person--new-person)
  - [call和.apply](#call%E5%92%8Capply)
  - [Function.prototype.bind作用](#functionprototypebind%E4%BD%9C%E7%94%A8)
  - [功能检测（feature detection）、功能推断（feature inference）和使用 UA 字符串之间有什么区别？](#%E5%8A%9F%E8%83%BD%E6%A3%80%E6%B5%8Bfeature-detection%E5%8A%9F%E8%83%BD%E6%8E%A8%E6%96%ADfeature-inference%E5%92%8C%E4%BD%BF%E7%94%A8-ua-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)
  - [同源策略](#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5)
  - [跨域问题](#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98)
    - [JSONP](#jsonp)
    - [postMessage](#postmessage)
    - [CORS(Cross orign resource share)跨域资源共享](#corscross-orign-resource-share%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB)
  - [如何实现浏览器内多个标签页之间的通信?](#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1)
  - [请解释变量提升（hoisting）。](#%E8%AF%B7%E8%A7%A3%E9%87%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87hoisting)
  - [“attribute” 和 “property” 之间有什么区别？](#attribute-%E5%92%8C-property-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)
  - [为什么扩展 JavaScript 内置对象是不好的做法？](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A9%E5%B1%95-javascript-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E5%A5%BD%E7%9A%84%E5%81%9A%E6%B3%95)
  - [请解释单页应用是什么，如何使其对 SEO 友好。](#%E8%AF%B7%E8%A7%A3%E9%87%8A%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E4%BD%BF%E5%85%B6%E5%AF%B9-seo-%E5%8F%8B%E5%A5%BD)
  - [polyfill](#polyfill)
  - [你使用什么语句遍历对象的属性和数组的元素？](#%E4%BD%A0%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E8%AF%AD%E5%8F%A5%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0)
  - [什么是事件循环？调用堆栈和任务队列之间有什么区别？](#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)
  - [请解释`function foo() {}`和`var foo = function() {}`之间`foo`的用法上的区别。](#%E8%AF%B7%E8%A7%A3%E9%87%8Afunction-foo-%E5%92%8Cvar-foo--function-%E4%B9%8B%E9%97%B4foo%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [使用let、var和const创建变量有什么区别？](#%E4%BD%BF%E7%94%A8letvar%E5%92%8Cconst%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)
  - [构造函数中使用箭头函数有什么好处？](#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84)
  - [请给出一个解构（destructuring）对象或数组的例子。](#%E8%AF%B7%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E8%A7%A3%E6%9E%84destructuring%E5%AF%B9%E8%B1%A1%E6%88%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90)
  - [DOM操作](#dom%E6%93%8D%E4%BD%9C)
- [HTML](#html)
  - [请描述事件冒泡](#%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1)
  - [请解释事件委托（event delegation）](#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98event-delegation)
  - [IE和firefox事件机制](#ie%E5%92%8Cfirefox%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6)
  - [给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件？](#%E7%BB%99%E4%B8%80%E4%B8%AAdom%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AA%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%B8%80%E4%B8%AA%E7%94%A8%E6%8D%95%E8%8E%B7%E4%B8%80%E4%B8%AA%E7%94%A8%E5%86%92%E6%B3%A1%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%87%A0%E6%AC%A1%E4%BA%8B%E4%BB%B6)
  - [`window`对象和`document`对象](#window%E5%AF%B9%E8%B1%A1%E5%92%8Cdocument%E5%AF%B9%E8%B1%A1)
  - [document 中的`load`事件和`DOMContentLoaded`事件之间的区别是什么？](#document-%E4%B8%AD%E7%9A%84load%E4%BA%8B%E4%BB%B6%E5%92%8Cdomcontentloaded%E4%BA%8B%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)
  - [页面编码和被请求的资源编码如果不一致](#%E9%A1%B5%E9%9D%A2%E7%BC%96%E7%A0%81%E5%92%8C%E8%A2%AB%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90%E7%BC%96%E7%A0%81%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%B8%80%E8%87%B4)
  - [http状态码](#http%E7%8A%B6%E6%80%81%E7%A0%81)
  - [Doctype作用, HTML5 为什么只需要写 \<!DOCTYPE HTML>, 标准模式与兼容模式有什么区别](#doctype%E4%BD%9C%E7%94%A8-html5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99-%5Cdoctype-html-%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%BC%E5%AE%B9%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)
  - [XML,SGML,HTML,XHTML,HTML5](#xmlsgmlhtmlxhtmlhtml5)
  - [行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？](#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B-%E7%A9%BAvoid%E5%85%83%E7%B4%A0%E6%9C%89%E9%82%A3%E4%BA%9B)
  - [使用`link`和`@import`区别](#%E4%BD%BF%E7%94%A8link%E5%92%8Cimport%E5%8C%BA%E5%88%AB)
  - [html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？](#html5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86html5%E6%96%B0%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86-html-%E5%92%8C-html5)
  - [HTML语义化](#html%E8%AF%AD%E4%B9%89%E5%8C%96)
  - [title与h1的区别、b与strong的区别、i与em的区别？](#title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%ABb%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%ABi%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？](#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%B9html5%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%82%A8%E5%AD%98%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E5%92%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%91%A2)
  - [iframe缺点](#iframe%E7%BC%BA%E7%82%B9)
  - [`Label`的作用是什么？是怎么用的？](#label%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84)
  - [Cookie隔离](#cookie%E9%9A%94%E7%A6%BB)
- [CSS](#css)
  - [盒子模型](#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B)
  - [CSS选择器](#css%E9%80%89%E6%8B%A9%E5%99%A8)
  - [display的值及作用](#display%E7%9A%84%E5%80%BC%E5%8F%8A%E4%BD%9C%E7%94%A8)
  - [position属性（定位原点）](#position%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%82%B9)
  - [居中div](#%E5%B1%85%E4%B8%ADdiv)
    - [水平居中](#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD)
    - [水平垂直居中](#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD)
    - [Flexbox（弹性盒布局模型)](#flexbox%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B)
  - [用纯css创建三角形](#%E7%94%A8%E7%BA%AFcss%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2)
  - [清除浮动](#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8)
    - [利用clear属性](#%E5%88%A9%E7%94%A8clear%E5%B1%9E%E6%80%A7)
    - [触发浮动元素父元素的BFC](#%E8%A7%A6%E5%8F%91%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E7%88%B6%E5%85%83%E7%B4%A0%E7%9A%84bfc)
    - [总结](#%E6%80%BB%E7%BB%93)
  - [CSS优化、提高性能的方式](#css%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E5%BC%8F)
  - [浏览器解析选择器过程](#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E9%80%89%E6%8B%A9%E5%99%A8%E8%BF%87%E7%A8%8B)
  - [全屏滚动原理](#%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E5%8E%9F%E7%90%86)
  - [伪类和伪元素](#%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0)
  - [元素竖向的百分比](#%E5%85%83%E7%B4%A0%E7%AB%96%E5%90%91%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94)
- [性能优化](#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)
  - [性能优化策略](#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5)
    - [服务器端](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF)
    - [request层面](#request%E5%B1%82%E9%9D%A2)
    - [html层面布局](#html%E5%B1%82%E9%9D%A2%E5%B8%83%E5%B1%80)
    - [JS端](#js%E7%AB%AF)
    - [css端](#css%E7%AB%AF)
- [浏览器，渲染引擎，JS内核（V8）](#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8Ejs%E5%86%85%E6%A0%B8v8)
- [安全](#%E5%AE%89%E5%85%A8)
  - [Web安全及防护原理, sql注入, XSS, CSRF](#web%E5%AE%89%E5%85%A8%E5%8F%8A%E9%98%B2%E6%8A%A4%E5%8E%9F%E7%90%86-sql%E6%B3%A8%E5%85%A5-xss-csrf)
    - [SQL注入](#sql%E6%B3%A8%E5%85%A5)
    - [XSS(cross-site scripting)](#xsscross-site-scripting)
    - [CSRF（Cross-site request forgery），跨站请求伪造](#csrfcross-site-request-forgery%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)
    - [Input_Path_Not_Canonicalized](#input_path_not_canonicalized)
    - [Absolute_Path_Traversal](#absolute_path_traversal)
    - [SSRF](#ssrf)
  - [对称/非对称加密，公钥和私钥](#%E5%AF%B9%E7%A7%B0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## JS
### JS基本数据类型及存储结构，内置对象

* Boolean, null, undefined, String, Number
* ES 2015 新增 : Symbol
  - 独一无二的变量，由于对象中的方法属性可能在传递分享时被不小心修改或覆盖，用Symbol可以保证唯一性。let s = Symbol();
* 储存结构
  - 基本(原始)数据类型在栈(stack)中存储，空间较小，大小固定，会被频繁调用；
  - 引用数据类型大小不固定，放在堆中存储

内置对象

Object对象：所有对象的父对象，原型链最上层
数据封装对象：Array, Boolean, String, Number, Object
其他： Math, Date, RegExp, Error, Function

### `null`, `undefined`区别, 未声明变量

null表示一个对象没有值，一般是程序员显示声明，Js不会自己设置为null，typeof(null)为Object

undefined表示一个变量声明了，但还没有初始化， typeof(undefined)为undefined

null === undefined 为true, null == undefined为false，目前的JS环境中，它们的差别很小，同时存在是因为历史原因，Js初期的设计参考了C等语言，在C中，null可以自动转型为0，由于JS的设计者Brendan Eich认为‘无’的概念最好不是一个对象，并且JS早期缺乏错误处理机制，null自动转型为0可能会造成一些不被察觉的错误，所以设计了undefined

当你没有提前使用var、let或const声明变量，就为一个变量赋值时，该变量是未声明变量（undeclared variables）。未声明变量会脱离当前作用域，成为全局作用域下定义的变量。在严格模式下，给未声明的变量赋值，会抛出ReferenceError错误。和使用全局变量一样，使用未声明变量也是非常不好的做法，应当尽可能避免。

### JavaScript是采用值传递还是引用传递的，并解释一下原理

### JS原型，原型链， 原型继承（prototypal inheritance）的工作原理

原型: JavaScript借鉴了面向对象语言‘一切皆是对象’的思想，对于每一个对象都存在一个prototype对象，也就是原型，prototype属性默认有一个constructor属性指向对象本身。

<img src="http://lrun1124.github.io/img/jsbase/prototype.png"/>

以内置对象Object为例，其prototype对象如下

<img src="http://lrun1124.github.io/img/jsbase/objectPrototype.png"/> 

可以看到其中包括了很多常用内置方法，在其他object调用这些方法的时候就是通过原型链生效的

原型链: JS的继承是通过原型链实现的。当JS的对象需要某个属性的时候，首先会从当前对象的属性中去找，找不到就会到原型prototype中去找，还是找不到就会沿着原型链向上寻找，直到找到Object.prototype，如果最终找不到，则返回null

### JS作用域，作用域链
* 全局作用域
	- 最外层定义的变量
	- 未定义直接赋值的变量
	- 顶层对象windows下的变量
* 局部作用域
  - var函数作用域
  - let, const

JS的作用域和Java,C++之类语言最大的区别就在于它的函数作用域，对于一些熟悉Java,C++语言的人，会造成一些难以理解的结果。可以通过几个例子来看一下：

### `闭包（closure）`，为什么使用闭包

<strong>闭包就是能够读取其他函数内部变量的函数</strong>, 即使被外部函数返回，依然可以访问到外部（封闭）函数作用域的函数。本质上是将函数内部和外部联系起来的桥梁。

```JS
function f1(){
	var n=999;
	function f2(){
		n++;
		alert(n);
	}
	return f2;
}
var result=f1();
result();//1000
result();//1001
```

以上代码通过内部的add在函数f1之外操作内部变量n，这里还体现了一个闭包的特点，可以看到在f1执行一次后n的值是被保存的，这是因为f2第一次在调用时被赋给了一个全局变量，而f2依赖于f1，所以f1的环境也始终被保存在内存中，不会被垃圾回收机制回收，所以<strong>大量使用闭包内存消耗很大，会导致性能下降</strong>>，第二个要注意地方时<strong>函数内部的值可能会被修改</strong>。

**为什么使用闭包？**

* 利用闭包实现数据私有化或模拟私有方法。
* 部分参数函数（partial applications）柯里化（currying）

### 请简述`JavaScript`中的`this`。

JS 中的`this`是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了`this`的值。

1. 在调用函数时使用`new`关键字，函数内的`this`是一个全新的对象。
1. 如果`apply`、`call`或`bind`方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。
1. 当函数作为对象里的方法被调用时，`this`指向直接调用者，函数内的`this`是调用该函数的对象。比如当`obj.method()`被调用时，函数内的 this 将绑定到`obj`对象。
1. 如果调用函数不符合上述规则，那么`this`的值指向全局对象（global object）。浏览器环境下`this`的值指向`window`对象，但是在严格模式下(`'use strict'`)，`this`的值为`undefined`。
1. 如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定`this`的值。
1. 如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，`this`被设置为它被创建时的上下文。

### `New`的过程

1. 创建空对象；
	- var obj = {};
1. 将创建出对象的原型链引用指向所要构造函数的原型；
	- obj.\__proto__ = ClassA.prototype; 
1. 调用构造函数，this指向新实例对象：
	- ClassA.call(obj);　　//{}.构造函数();          
1. 将初始化完毕的新对象地址，保存到等号左边的变量中

### 不会查找原型的函数

object.hasOwnProperty(proName), 判断对象中是否有指定名称的属性

### for in和for of

1. for...in循环出的是key，for...of循环出的是value
1. for...of是ES6对于forEach的改善，for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。for of只可以循环可迭代对象的可迭代属性，不可迭代属性在循环中被忽略了（优点1）；可以与break、continue和return配合使用。（优点2）

结论：推荐在循环对象属性的时候，使用for...in,在遍历数组的时候的时候使用for...of。

### Ajax流程，手动写，Ajax缓存
Asynchronous JavaScript and Xml, 异步传输+JS+xml，异步的含义是在向服务器发送请求后，不必等待响应，可以先做其他的事，等相应返回可以根据设定的callback函数进行操作，于此同时，网页不会发生整页刷新，提高了效率和用户体验。

步骤：

1. 创建XMLHttpRequest对象
2. 设置响应HTTP请求状态变化的函数
3. 指定该对象的的方法、URL及验证信息
4. 发送HTTP请求
5. 获取异步调用返回的数据
6. 使用JavaScript和DOM实现局部刷新

```html
<button id="ajaxButton" type ="button">Make Ajax request</button>

<script>
var httpRequest;
document.getElementbyId('ajaxButton').addEventListener("click", sendRequest);

function sendRequest(){
	httpRequest = new XMLHttpRequest(); //1

	if(httpRequest){
		alert('Cannot creat XMLHttpRequest');
		return;
	}

	httpRequest.onreadystatechange = stateFunction;//2
	httpRequest.open('GET', 'test.html');//3
	httpRequest.send();//4
}

function stateFunction(){
	if(httpRequest.readyState === XMLHttpRequet.Done){
		if(httpRequest.state === 200){
			alert(httpRequest.responseText);//5
			//... 6
		}
		else{
			alert('The request has some problem');
		}
	}
}
</script>
```
### 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？
放在body的封闭之前，将会阻塞其他资源的加载，放在body封闭之后，不会影响body内元素的加载

### 延迟加载，defer，async，动态dom，分组加载

JS延迟加载就是在页面加载完成后再加载JS文件，有助于提高页面加载速度，提高用户体验。

#### 使用defer或async属性

```html
<script src="test1.js" defer="defer"></script>
<script src="test2.js" async></script>
```
- 只适用于外部脚本，缺点是不能保证脚本会按顺序执行

当浏览器碰到 script 脚本的时候，没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

* 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。
* 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

<img src="http://lrun1124.github.io/img/jsbase2/defer&async.jpg"/>

#### 动态DOM操作

即利用动态DOM操作按需插入JS文件，比如onload后延时插入js

```js
//延迟1000ms加载new.js
window.onload = function(){
	setTimeout(function(){
		var head = document.getElementByTagName('head')[0];
		var js = document.createElement('Script');
		js.type = 'text/javascript';
		js.src = '.../new.js';
		head.appendChlid(js); 
	},1000);
}
```

#### 分组最后加载JS

JS的引入如果放在head中，则页面加载前JS就会被加载，如果放在body中，则会按顺序加载，所以可以将JS分组，对于加载过程中不需要的JS，可以放在页面的底部，</body>标签之前，然而这种方法偶尔会收到Google页面速度测试工具的“延迟加载javascript”警告，Google提供了一套推荐方案：

```html
//这些代码应被放置在</body>标签前(接近HTML文件底部)
<script type="text/javascript">
    function downloadJSAtOnload() {
        var element = document.createElement("script");
        element.src = "defer.js";
        document.body.appendChild(element);
    }
    if (window.addEventListener)
        window.addEventListener("load", downloadJSAtOnload, false);
    else if (window.attachEvent)
        window.attachEvent("onload", downloadJSAtOnload);
    else window.onload = downloadJSAtOnload;
</script>
```

这段代码意思是等到整个文档加载完后，再加载外部文件“defer.js”。

使用此段代码的步骤：

1. 复制上面代码；
1. 粘贴代码放置在</body>标签前 (靠近HTML文件底部)；
1. 修改“defer.js”为外部JS文件名；
1. 确保文件路径是正确的。例如：如果仅输入“defer.js”，那么“defer.js”文件一定与HTML文件在同一文件夹下。

注意：这段代码直到文档加载完才会加载指定的外部js文件。因此，不应该把那些页面正常加载需要依赖的javascript代码放在这里。

总结： 
应该将JavaScript代码分成两组。
1. 一组是因页面需要而立即加载的javascript代码。放在head中用async/defer
1. 另外一组是在页面加载后进行操作的javascript代码(例如添加click事件或其他东西)。这些需等到页面加载后再执行的JavaScript代码，应放在一个外部文件，然后再引进来。然后从实用角度来说呢，把这些脚本都丢到 </body> 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析j

另一方面外部的js一般放到head内，内部的js一般放到body内，这样做的目的有很多
1. 不阻塞页面的加载(事实上js会被缓存)；
1. 可以直接在js里操作dom，这时候dom是准备好的，即保证js运行时dom是存在的。

而 CSS 应当写在 head 中，以避免页面元素由于样式缺失造成瞬间的白页或者给用户闪烁感。在head内的js一般要先执行完后，才开始渲染body页面。为了避免head引入的js脚本阻塞流浪器中主解析引擎对dom的解析工作，对dom的渲染，一般原则是，样式在前面，dom文档，脚本在最后面。遵循先解析再渲染再执行script这个顺序。 

//Todo...

### get和post
GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符
POST：一般用于修改服务器上的资源，对所发送的信息没有限制。

GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，
也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。

然而，在以下情况中，请使用 POST 请求：
1. 无法使用缓存文件（更新服务器上的文件或数据库）
1. 向服务器发送大量数据（POST 没有数据量限制）
1. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

### 同步和异步

对于Web而言：<br />
同步: 访问服务器，服务器回应，页面刷新，用户操作，整个过程是串行的方式进行的，影响用户操作<br />
异步: 访问服务器，用户继续操作，服务器回应，页面更新，用户操作，整个过程不发生整页刷新，不影响用户操作<br />

### 前端模块化，AMD/CMD/CommonJS

知识点1：AMD(Asynchronous Module Definition)/CMD(Common Module Definition)/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs.

知识点2：CommonJs主要针对服务端，AMD/CMD主要针对浏览器端，所以最容易混淆的是AMD/CMD。（顺便提一下，针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行。这里如果有其他后端语言，如java，经验的‘玩家’应该更容易理解。而浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好。）

知识点3 : AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。

知识点4：AMD/CMD的优缺点.一个的优点就是另一个的缺点， 可以对照浏览。

AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。<br />
AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。

CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。<br />
CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。

知识点5：如何使用？CommonJs的话，因为nodeJs就是它的实现，所以使用node就行，也不用引入其他包。AMD则是通过\<script>标签引入RequireJs，CMD则是引入SeaJs。

### 内存泄漏

内存泄漏时指一块被分配的内存既不能使用也不能回收。在JavaScipt出现主要有两种情况:

1.循环引用。含有DOM对象的循环引用将导致大部分当前主流浏览器内存泄露。

```js
//a,b循环引用
var a = new Object;
var b = new Object;
a.r = b;
b.r = a;

//a循环引用自己
var a = new Object;
a.r = a;
```

1.闭包。闭包可以导致内存泄漏是因为内部方法保持一个对外部方法变量的引用，所以尽管方法返回了内部方法还可以继续访问在外部方法中定义的私有变量，所以这些变量被一直保存在内存中。

1.setTimeout的第一个参数使用字符串而非函数的话，会引发内存泄漏

### ==, ===, Object.is()区别

==会进行类型转换，===不会，Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.

### 前端设计模式，单例，单体，工厂，策略，装饰者，适配器，观察者，门面

#### 单体模式(Singleton)

将一批属性和方法组织在一起的对象，用来划分命名空间。其特点：<br />
1. 划分命名空间，只暴露一个入口，减少全局变量带来的风险
2. 利用分支技术来来封装浏览器之间的差异。
3. 可以把代码组织的更为一体，便于阅读和维护。

```js
var singleton = {
    attribute: {},
    method1: function(){},
    method2: function(){}
}
```

#### 单例模式(Single)

单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点

```js
var single = (function(){
    var unique;

    function getInstance(){　　　　// 如果该实例存在，则直接返回，否则就对其实例化
        if( unique === undefined ){
            unique = new Construct();
        }
        return unique;
    }

    function Construct(){
        // ... 生成单例的构造函数的代码
    }

    return {
        getInstance : getInstance
    }
})();
```

#### 工厂模式(Factory)

提供一个创建对象的借口，无需指定具体的类，把成员对象的创建工作转交给一个外部对象，<strong>好处在于消除对象之间的耦合(也就是相互影响), 有助于创建模块化的代码</strong>

<strong>简单工厂模式</strong>：使用一个类，通常为单体，来生成实例。典型的实例，xhr工厂。

```js
   var XMLHttpFactory =function(){};　　　　　　//这是一个简单工厂模式
　　XMLHttpFactory.createXMLHttp =function(){
　　　 var XMLHttp = null;
　　　　if (window.XMLHttpRequest){
　　　　　　XMLHttp = new XMLHttpRequest()
　　　 }else if (window.ActiveXObject){
　　　　　　XMLHttp = new ActiveXObject("Microsoft.XMLHTTP")
　　　　}
　　return XMLHttp;
　　}
　　//XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。
　　var AjaxHander =function(){
　　　　var XMLHttp = XMLHttpFactory.createXMLHttp();
　　　　...
　　}
```
<strong>复杂工厂模式</strong>：先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法

```js
var XMLHttpFactory =function(){};　     //这是一个抽象工厂模式

XMLHttpFactory.prototype = {
　　//如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类
　　createFactory:function(){
  　　throw new Error('This is an abstract class');
　　}
}

var XHRHandler =function(){}; //定义一个子类

// 子类继承父类原型方法
extend( XHRHandler , XMLHttpFactory );

XHRHandler.prototype =new XMLHttpFactory(); //把超类原型引用传递给子类,实现继承

XHRHandler.prototype.constructor = XHRHandler; //重置子类原型的构造器为子类自身

//重新定义createFactory 方法
XHRHandler.prototype.createFactory =function(){
　　var XMLHttp =null;
　　if (window.XMLHttpRequest){

  　　XMLHttp =new XMLHttpRequest();

　　}else if (window.ActiveXObject){

  　　XMLHttp =new ActiveXObject("Microsoft.XMLHTTP")
　　}

　　return XMLHttp;
}
```
应用场景：

以下几种情景下工厂模式特别有用：

1. 对象的构建十分复杂
2. 需要依赖具体环境创建不同实例
3. 处理大量具有相同属性的小对象

优点：

可以实现一些相同的方法，这些相同的方法我们可以放在父类中编写代码，那么需要实现具体的业务逻辑，那么可以放在子类中重写该父类的方法，去实现自己的业务逻辑；

也就是说有两点：　　

1. 弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。
2. 重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。

缺点：

当工厂增加到一定程度的时候，提升了代码的复杂度，可读性下降。而且没有解决对象的识别问题，即怎么知道一个对象的类型。

#### 策略模式(Strategy)

策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。

代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额。

没有使用策略模式的情况：
```js
function Price(personType, price) {
    //vip 5 折
    if (personType == 'vip') {
        return price * 0.5;
    } 
    else if (personType == 'old'){ //老客户 3 折
        return price * 0.3;
    } else {
        return price; //其他都全价
    }
}
```
不足之处：不好的地方，当我有其他方面的折扣时，又或者我活动的折扣时经常变化的，这样就要不断的修改if..else里面的条件了。而且也违背了设计模式的一个原则：<strong>对修改关闭，对扩展开放的原则</strong>；

使用策略模式之后：
```js
// 对于vip客户
function vipCustomer() {
    this.discount = 0.5;
}
 
vipCustomer.prototype.getPrice = function(price) {
　　return price * this.discount;
}
// 对于老客户
function oldCustomer() {
    this.discount = 0.3;
}
 
oldCustomer.prototype.getPrice = function(price) {
    return price * this.discount;
}
// 对于普通客户
function normalCustomer() {
    this.discount = 1;
}
 
normalCustomer.prototype.getPrice = function(price) {
    return price ;
}

// 上下文，对于客户端的使用
function Context() {
    this.name = '';
    this.strategy = null;
    this.price = 0;
}
 
Context.prototype.set = function(name, strategy, price) {
    this.name = name;
    this.strategy = strategy;
    this.price = price;
}
Context.prototype.getResult = function() {
    console.log(this.name + ' 的结账价为: ' + this.strategy.getPrice(this.price));
}

var context = new Context();
var vip = new vipCustomer();
context.set ('vip客户', vip, 200);
context.getResult();   // vip客户 的结账价为: 100

var old = new oldCustomer();
context.set ('老客户', old, 200);
context.getResult();  // 老客户 的结账价为: 60

var Price = new normalCustomer();
context.set ('普通客户', Price, 200);
context.getResult();  // 普通客户 的结账价为: 200
```

#### 装饰者模式（decrator）

动态地给一个对象添加一些新的方法。就扩展功能而言，它比生成子类方式更为灵活。装饰者的运作过程是透明的，这就是说你可以用它包装其他对象，然后继续按之前使用那么对象的方法来使用。

```js
var myText= {};
myText.Decorations={};
myText.Core=function(myString){
    this.show =function(){return myString;}
}
//第一次装饰，string后加？
myText.Decorations.addQuestuibMark =function(myString){
    this.show =function(){return myString.show()+'?';};
}
//第二次装饰，添加标签
myText.Decorations.makeItalic =function(myString){
    this.show =function(){return'<li>'+myString.show()+'</li>'};
}
//得到myText.Core的实例
var theString =new myText.Core('this is a sample test String');
alert(theString.show());　　//output 'this is a sample test String'

//得到？装饰后的String
theString =new myText.Decorations.addQuestuibMark(theString);
alert(theString.show());　　//output 'this is a sample test String?'

//得到标签装饰后的String
theString =new myText.Decorations.makeItalic (theString);
alert(theString.show());　　//output '<li>this is a sample test String</li>'
```

从这个示例中可以看出，我们的目的是为了得到装饰过得String，这一切都可以不用事先知道组件对象的接口，也就是说我们只需要调用myString.show()，而其中具体的实现不用关心，甚至可以动态的实现。

在为现有对象增添特性这方面，装饰者模式有极大的灵活性。如果需要为类增加特性或者方法，而从该类派生子类的解决办法并不实际的话，就应该使用装饰者模式。派生子类之所以会不实际最常见的原因是需要添加的特性或方法的数量要求使用大量子类。

#### 适配器模式（Adapter）

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作，使用这种模式的对象又叫包装器，因为他们是在用一个新的接口包装另一个对象。

```js
//一个参数为两个字符串的接口函数
var interface = function(str1, str2){
    ...
}
//现在我们想使用上面接口函数，但是参数是一个对象
var test = {
    str1 : '1',
    str2 : '2'
}
//适配器函数
var adapterMethod = function(obj){
    return interface(obj.str1, obj.str2);
}
//调用
adapterMethod(test);
```

#### 观察者模式（Observer）

定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。典型的是事件监听器绑定。

```html
<div id='test'>test</div>
<script>
var fn1 = function(){
    ...
}
var fn2 = function(){
    ...
}
var test = document.getElementsById('test');
//绑定两个监听click事件
test.addElementListener('click', fn1, false);
test.addELementListener('click', fn2, false);
</script>
```

#### 门面模式（facede）

子系统中的一组接口提供一个一致的界面，门面模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。实际上就是把一组工具函数包装在一个对象里，对外的门面就是这个对象，<strong>门面模式是几乎所有JavaScript库的核心原则</strong>。

### 优雅降级和渐进增强
优雅降级：Web站点在所有新式浏览器中都能正常工作的前提下，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：border-shadow

渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；
### Node的优缺点
Node的优缺点

（优点) 因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
    因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
    此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，
    因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，
    而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。
### GC机制，v8 GC机制
####  引用计数

传统的GC方法，维护对象的引用计数器，引用为0时清除，优点是清除及时，清除时间均匀分布，缺点主要是循环引用问题

#### V8机制

<img src="http://lrun1124.github.io/img/jsgc.png" width="450"/>

遵循的主旨
* 大部分新生对象倾向于早死；
* 不死的对象，会活得更久。
将内存分为新生带和老生带两部分

##### 全停顿
需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「全停顿」（Stop The World）, 原因是为避免应用逻辑与垃圾回收器看到的情况不一致。  

##### 新生代

Scavenge垃圾回收算法进行管理，主要实现是Cheney算法，将内存分为两部分，From和To，新建对象都进入From空间中，当From空间分配到一定程度，扫描一遍，将存活对象对象copy到To空间，清空From空间，然后调换From和To空间，继续进行分配，当一个对象被多次移动后仍然存活，或者如果一个对象被复制到To空间，To空间占用超过阈值（25%），这个对象会被移到老生带

##### 老生带

综合使用Mark-Sweep标记清除和Mark-compact标记整理, Mark-Sweep是当GC触发时，从根节点出发对所有能到达的对象进行遍历，一般是深度优先搜索，对能达到对象进行标记，最后清除掉未被标记的对象，Mark-Sweep会产生碎片内存，Mark-compact是将使用的内存向一侧移动，然后清楚掉内存的边界，由于Mark-compact需要移动对象，所以速度不会很快，V8上尽量才去Mark-Sweep，当内存不足以对新生代晋升过来的对象进行分配时，再进行Mark-compact

##### Incremental Marking（增量标记）
在新生代中，由于存活对象少，垃圾回收效率高，全停顿时间短，造成的影响小。但是老生代中，存活对象多，垃圾回收时间长，全停顿造成的影响大。为了减少全停顿的时间，V8对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。从2011年起，v8就将「全暂停」标记换成了增量标记。改进后的标记方式，最大停顿时间减少到原来的1/6。

现代V8引擎对垃圾回收进行了很多改进，比如，在Chrome 64和Node.js v10中V8启用了「并行标记」技术，将标记时间缩短了60%~70%。还有「Parallel Scavenger」技术，它将新生代的垃圾回收时间缩短了20%~50%。

### Cookie和Session

1. session 在服务器端，cookie 在客户端（浏览器）
2. session 默认被存在在服务器的一个文件里（不是内存）
3. session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
4. session 可以放在 文件、数据库、或内存中都可以。
5. 用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id
6. cookie是不安全的，一些网络攻击如XSS和CSRF可以获取cookie或进行cookie欺骗，所以重要信息放在session里，必要放在cookie里要枷锁

### cookie, loaclStorage, sessionStorage

1. cookie: 可设置失效时间，默认是浏览器关闭后，大小4K左右，每次都会携带在HTTP头中，这也是大小限制的原因，如果使用cookie保存过多数据会带来性能问题，主要用于保存密码等信息
1. localStorage: 除非主动删除，否则永久保留，一般5M左右，仅在浏览器保存，不参与通信
1. sessionStorage: 仅在当前会话下有效，刷新不删除，关闭页面或浏览器清除，一般5M左右，仅在浏览器保存，不参与通信
1. 另外sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

### javascript继承的6种方法

### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

1. 再输入url的时候，浏览器可能会做一些预处理，比如 Chrome 会根据历史统计来预估所输入字符对应的网站，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「www.baidu.com 」，因此就会在输入回车前就马上开始建立 TCP 链接甚至渲染了，还有很多其它很多优化策略
1. 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
1. 浏览器内核中会先查看缓存，然后调用浏览器内核中的对应方法;
1. 进行DNS解析，使用UDP协议获取网址的IP地址;
1. 设置 UA 等信息发出第二个GET请求，进行HTTP协议会话，客户端发送报头(请求报头);
1. 进过运营商路由，主干网传输，进入到相应服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
1. 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的处理过程;
1. 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回http状态码304，表示网页未修改过;
1. 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;
1. 转交给Renderer进程. 开始渲染
1. 解析html建立dom树
1. 解析css构建CSSOM 树（Recaculate Style）
1. 合并 DOM 树与 CSSOM 树为 Render 树
1. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
1. 绘制render树（paint），绘制页面像素信息
1. 浏览器会将各层的信息发送给GPU，GPU会将各层复合图层化（composite），显示在屏幕上。
1. 渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了

### JSON的了解

JSON（JavaScript Object Notation）是一种<strong>轻量级的数据交换格式</strong>，是基于JavaScript的一个子集，具有<strong>数据格式简单，易于读写且占用带宽小</strong>的优点。

字符串转对象：

```JS
JSON.parse(str);
str.parseJSON(str);
eval('(' + str + ')')
```

对象转字符串：

```JS
JSON.stringify(obj);
obj.toJSONString(str);
```

### XML和JSON
1. 数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。
1. 数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
1. 数据描述方面。JSON对数据的描述性比XML较差。
1. 传输速度方面。JSON的速度要远远快于XML。

### MVC和MVVM的理解

MVC:View 传送指令到 Controller, Controller 完成业务逻辑后，要求 Model 改变状态, Model 将新的数据发送到 View，用户得到反馈, 所有通信都是单向的。

MVVM： 典型的Angular，它采用双向绑定（data-binding）：View的变动，自动反映在ViewModel，反之亦然。组成部分Model、View、ViewModel

View：UI界面

ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；

Model：数据访问层

### forEach循环和.map()循环的主要区别，它们分别在什么情况下使用？

都是遍历数组，forEach为每个元素执行回调，最终无返回值，map每个元素返回一个新值，最后返回新数组

匿名函数的典型应用场景是什么？

1. 匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。

```js
(function() {
  // 一些代码。
})();
```
1. 只使用一次的回调函数，不需要具体函数名，便于维护和提高可读性

1. 用于函数式编程

### 宿主对象（host objects）和原生对象（native objects）的区别是什么？

原生对象是由 ECMAScript 规范定义的 JavaScript 内置对象，比如`String`、`Math`、`RegExp`、`Object`、`Function`等等。

宿主对象是由运行时环境（浏览器或 Node）提供，比如`window`、`XMLHTTPRequest`等等。

### 下列语句有什么区别：function Person(){}、var person = Person()和var person = new Person()？


这个问题问得很含糊。我猜这是在考察 JavaScript 中的构造函数（constructor）。从技术上讲，`function Person(){}`只是一个普通的函数声明。使用 PascalCase 方式命名函数作为构造函数，是一个惯例。

`var person = Person()`将`Person`以普通函数调用，而不是构造函数。如果该函数是用作构造函数的，那么这种调用方式是一种常见错误。通常情况下，构造函数不会返回任何东西，因此，像普通函数一样调用构造函数，只会返回`undefined`赋给用作实例的变量。

`var person = new Person()`使用`new`操作符，创建`Person`对象的实例，该实例继承自`Person.prototype`。另外一种方式是使用`Object.create`，例如：`Object.create(Person.prototype)`。

### call和.apply
```js
function.call(this, arg1, arg2, arg3) 
function.apply(this, [arg1, arg2, arg3]) 
this.function(arg1, arg2, arg3)
```

### Function.prototype.bind作用

> `bind()`方法创建一个新的函数, 当被调用时，将其 this 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。


### 功能检测（feature detection）、功能推断（feature inference）和使用 UA 字符串之间有什么区别？

**功能检测（feature detection）**

功能检测包括确定浏览器是否支持某段代码，以及是否运行不同的代码（取决于它是否执行），以便浏览器始终能够正常运行代码功能，而不会在某些浏览器中出现崩溃和错误。例如：

```js
if ('geolocation' in navigator) {
  // 可以使用 navigator.geolocation
} else {
  // 处理 navigator.geolocation 功能缺失
}
```

[Modernizr](https://modernizr.com/)是处理功能检测的优秀工具。

**功能推断（feature inference）**

功能推断与功能检测一样，会对功能可用性进行检查，但是在判断通过后，还会使用其他功能，因为它假设其他功能也可用，例如：

```js
if (document.getElementsByTagName) {
  element = document.getElementById(id);
}
```

非常不推荐这种方式。功能检测更能保证万无一失。

**UA 字符串**

这是一个浏览器报告的字符串，它允许网络协议对等方（network protocol peers）识别请求用户代理的应用类型、操作系统、应用供应商和应用版本。它可以通过`navigator.userAgent`访问。 然而，这个字符串很难解析并且很可能存在欺骗性。例如，Chrome 会同时作为 Chrome 和 Safari 进行报告。因此，要检测 Safari，除了检查 Safari 字符串，还要检查是否存在 Chrome 字符串。不要使用这种方式。

### 同源策略

同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。


### 跨域问题

#### JSONP

* 由于同源政策的存在，Ajax直接请求普通文件存在跨域无权限访问的问题，无论是静态页面、动态网页、web服务，只要是跨域请求，一律不准；另一方面，通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，这些拥有"src"这个属性的标签都拥有跨域的能力，比如\<script>、\<img>、\<iframe>等标签。 
* JSONP正是利用这一点，web客户端通过与调用脚本一模一样的方式来调用跨域服务器上的资源，服务器端则动态生成JSON，把客户端需要的数据装入进去。
* 其缺点是只能实现get一种请求。

```html
 <script>
 //原生实现
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参并指定回调执行函数为onBack
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack';
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
 </script>
```

跨来源资源共享（CORS） 是推荐的主流方式，JSONP 已被视为一种比较 hack 的方式

#### postMessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：

1. 页面和其打开的新窗口的数据传递
2. 多窗口之间消息传递
3. 页面与嵌套的iframe消息传递
4. 上面三个场景的跨域数据传递

用法：postMessage(data,origin)方法接受两个参数

data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br />
origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

1.）a.html：(http://www.domain1.com/a.html)

```html
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };

    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);
</script
```

2.）b.html：(http://www.domain2.com/b.html)

```html
<script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---> ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
</script>
```

#### CORS(Cross orign resource share)跨域资源共享

服务器端设置Access-Control-Allow-Origin,前端无须设置

“\*”号表示允许任何域向我们的服务端提交请求：Access-Control-Allow-Origin：*
     
也可以设置指定的域名，如域名 http://www.test2.com ，那么就允许来自这个域名的请求：Access-Control-Allow-Origin：http://www.test2.com

若要带cookie请求：前后端都需要设置

```js
var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
    }
};
```
### 如何实现浏览器内多个标签页之间的通信?

1. WebSocket、SharedWorker；
1. 也可以调用localstorge、cookies等本地存储方式；localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；

### 请解释变量提升（hoisting）。

使用`var`关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。

```js
// 用 var 声明得到提升
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// 用 let/const 声明不会提升
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升，也就是说函数不能提前调用 

```js
// 函数声明
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]

// 函数表达式
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]
```

### “attribute” 和 “property” 之间有什么区别？

“Attribute” 是在 HTML 中定义的，而 “property” 是在 DOM 上定义的。为了说明区别，假设我们在 HTML 中有一个文本框：`<input type="text" value="Hello">`。

```js
const input = document.querySelector('input');
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello
```

但是在文本框中键入“ World!”后:

```js
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello World!
```

### 为什么扩展 JavaScript 内置对象是不好的做法？

扩展 JavaScript 内置（原生）对象意味着将属性或方法添加到其`prototype`中。虽然听起来很不错，但事实上这样做很危险。想象一下，你的代码使用了一些库，它们通过添加相同的 contains 方法来扩展`Array.prototype`，如果这两个方法的行为不相同，那么这些实现将会相互覆盖，你的代码将不能正常运行。

扩展内置对象的唯一使用场景是创建 polyfill，本质上为老版本浏览器缺失的方法提供自己的实现，该方法是由 JavaScript 规范定义的。

### 请解释单页应用是什么，如何使其对 SEO 友好。

单页面（SPA）应用是服务器端只返回一个html的web，使用客户端渲染，SPA 通过 JavaScript 来动态更新页面，这些 JavaScript 在初始页面加载时已经下载，有些爬虫程序并不会执行JS，所以不利于SEO，可以在服务器端渲染应用，首屏服务器端渲染还可以加快首屏响应速度，或者使用诸如 Prerender 的服务来“在浏览器中呈现的 javascript，保存静态 HTML，并将其返回给爬虫”。

### polyfill

我们希望浏览器提供一些特性，但是没有，然后我们自己写一段代码来实现他，那这段代码就是补丁

### 你使用什么语句遍历对象的属性和数组的元素？

数组用forEach, for of(可break, continue), 对象遍历key用for in，不过会遍历到遍历到它的继承属性，在使用之前，需要加入obj.hasOwnProperty(property)检查

for...of是ES6对于forEach的改善，for of只可以循环可迭代对象的可迭代属性，不可迭代属性在循环中被忽略了（优点1）；可以与break、continue和return配合使用。（优点2）

### 什么是事件循环？调用堆栈和任务队列之间有什么区别？

事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。

### 请解释`function foo() {}`和`var foo = function() {}`之间`foo`的用法上的区别。

前者是函数声明，后者是函数表达式。关键的区别在于函数声明会使函数体提升（具有与变量相同的提升行为），但函数表达式的函数体不能。有关变量提升的更多解释，请参阅上面关于变量提升的问题。如果你试图在定义函数表达式之前调用它，你会得到一个`Uncaught TypeError: XXX is not a function`的错误。

**函数声明**

```js
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
```

**函数表达式**

```js
foo(); // Uncaught TypeError: foo is not a function
var foo = function() {
  console.log('FOOOOO');
};
```

### 使用let、var和const创建变量有什么区别？

1. 用var声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数（函数作用域），也可以是声明在任何函数外的变量。let和const是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问
1. var会使变量提升，这意味着变量可以在声明之前使用。let和const不会使变量提升，提前使用会报错。
1. 用var重复声明不会报错，但let和const会。
1. let和const的区别在于：let允许多次赋值，而const只允许一次。

### 构造函数中使用箭头函数有什么好处？
1. 简介
1. 正常函数的 this 是可以在执行过程中被改变的，而箭头函数的 this 则会一直保持一致。所以在使用箭头函数的时候，你就不需要担心它的上下文被改变了。

```js
const Person = function(firstName) {
  this.firstName = firstName;
  this.sayName1 = function() { console.log(this.firstName); };
  this.sayName2 = () => { console.log(this.firstName); };
};

const john = new Person('John');
const dave = new Person('Dave');

john.sayName1(); // John
john.sayName2(); // John

// 普通函数的 this 可以被修改，而箭头函数则不会
john.sayName1.call(dave); // Dave (因为 "this" 现在指向了 dave 对象)
john.sayName2.call(dave); // John

john.sayName1.apply(dave); // Dave (因为 "this" 现在指向了 dave 对象)
john.sayName2.apply(dave); // John

john.sayName1.bind(dave)(); // Dave (因为 "this" 现在指向了 dave 对象)
john.sayName2.bind(dave)(); // John

var sayNameFromWindow1 = john.sayName1;
sayNameFromWindow1(); // undefined (因为 "this" 现在指向了 Window 对象)

var sayNameFromWindow2 = john.sayName2;
sayNameFromWindow2(); // John
```

这在 React 的类组件里非常有用。如果你使用普通的函数来定义一个类方法，比如一个点击处理函数，然后你将这个点击处理函数通过 prop 的形式传递给子节点，你将必须在父组件的 `constroctor` 里使用 `fn.bind(this)` 的形式来确保该函数能正常工作。但是如果你使用箭头函数的话，你就不需要手动去绑定 `this` 了，因为箭头函数会自动绑定创建时的 `this`。

### 请给出一个解构（destructuring）对象或数组的例子。

解构是 ES6 中新功能，它提供了一种简洁方便的方法来提取对象或数组的值，并将它们放入不同的变量中。

**数组解构**

```js
// 变量赋值
const foo = ['one', 'two', 'three'];

const [one, two, three] = foo;
console.log(one); // "one"
console.log(two); // "two"
console.log(three); // "three"
```

```js
// 变量交换
let a = 1;
let b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1
```

**对象解构**

```js
// 变量赋值
const o = { p: 42, q: true };
const { p, q } = o;

console.log(p); // 42
console.log(q); // true
```
### DOM操作
```
//创建
createElement() //创建元素
createDocumentFragment()  //创建DOM片段
createTextNode() //创建文本节点

//操作
appendChild() //添加
removeChild() //删除
replaceChild() //替换
insertbefore() //在已有节点前插入新节点

//查找
getElementsById()
getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
getElementsByTag()
getElementsByClass()
```

## HTML

### 请描述事件冒泡
当一个事件在 DOM 元素上触发时，如果有事件监听器，它将尝试处理该事件，然后事件冒泡到其父级元素，并发生同样的事情。最后直到事件到达祖先元素。事件冒泡是实现事件委托的原理（event delegation）。

### 请解释事件委托（event delegation）

将时间监听添加到父元素，而不是每个子元素单独设置，当事件冒泡到父元素，监听器就会触发，好处：

* 内存占用减少，只需一个父元素监听事件
* 利于修改和维护，删除/添加的元素无需解绑和修改

### IE和firefox事件机制

IE是事件冒泡，firefox同时支持事件冒泡和捕获
* 事件捕获: 越高层的元素越早接收到事件，由上到下
* 事件冒泡: 越低层的元素越早接收到时间，由下到上

阻止冒泡事件的方法
### 给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件？
绑定几个事件就执行几次，执行优先级:

1. 父元素的捕获事件
1. 目标元素的顺序事件，无视捕获还是冒泡
1. 父元素的冒泡事件

也就是说从外层到内层再回到外层
target.addEventListener(type, listener[, options]);
```html
<div class='d1'>
    <div class='d2'></div>
</div>

<script type='text/javascript'>
var d1 = document.getElementsByClass('d1');
var d2 = document.getElementsByClass('d2');
     
//父级绑定click事件冒泡
d1.addEventListener('click', function(){ console.log('parent bubble') }, false);

//子级绑定click事件冒泡
d2.addEventListener('click', function(){ console.log('child bubble') }, false);

//子级绑定click事件捕获
d2.addEventListener('click', function(){ console.log('child capture') }, true);

//父级绑定click事件捕获
d1.addEventListener('click', function(){ console.log('parent capture') }, true);
</script>
```

console:
```
parent capture
child bubble
child capture
parent bubble
```
### `window`对象和`document`对象

window对象是浏览器打开的窗口，顶层对象，document是window对象的一个属性，HTML文档对象的一个<strong>只读引用</strong>

```js
xxx.click = function(e){
	e.stopPropagation();
	e.cancelBubble = true;//旧IE需要
}
```
### document 中的`load`事件和`DOMContentLoaded`事件之间的区别是什么？

1. 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。
1. 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。

### 页面编码和被请求的资源编码如果不一致
设置charset
```html
<script src="http://www.xxx.com/test.js" charset="utf-8"></script>
```

### http状态码
```
100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200  OK         正常返回信息
201  Created    请求成功并且服务器创建了新的资源
202  Accepted   服务器已接受请求，但尚未处理
301  Moved Permanently  请求的网页已永久移动到新位置。
302  Found       临时性重定向。
303  See Other   临时性重定向，且总是使用 GET 请求新的 URI。
304  Not Modified 自从上次请求后，请求的网页未修改过。
400  Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401  Unauthorized 请求未授权。
403  Forbidden   禁止访问。
404  Not Found   找不到如何与 URI 相匹配的资源。
500  Internal Server Error  最常见的服务器端错误。
503  Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
```

### Doctype作用, HTML5 为什么只需要写 \<!DOCTYPE HTML>, 标准模式与兼容模式有什么区别
1. \<!DOCTYPE>`声明位于位于HTML文档中的第一行，处于 \<html>` 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
1. 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。

HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行)HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。

### XML,SGML,HTML,XHTML,HTML5

他们都是ML，都是标记语言（Markup Language），所以不同就是前面的部分了。
1. SGML(Standard Generalized Markup Language)，即标准通用标记语言, 是一种古老，复杂的标准
1. HTML(HyperText Markup Language)，超文本标记语言，是语法较为松散的、不严格的Web语言，SGML的子集，其中的HTML5已经不是SGML的子集了
1. XML（eXtensible Markup Language），可扩展标记语言，主要用于存储数据和结构，可扩展，SGML的子集
1. XHTML（eXtensible HyperText Markup Language），可扩展超文本标记语言，基于XML，作用与HTML类似，但语法更严格。所有标签必须闭合，每一个属性都必须使用引号包住，所有<和&特殊符号用编码表示。\<br>要写成\<br />，不能写为\<BR />（同hr）；使用了\<p>之后必须有一个\</p>以结束段落。

### 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？
CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。
1. 行内元素有：a b span img input select strong（强调的语义）
1. 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p
1. 常见的空元素：\<br> \<hr> \<img> \<input> \<link> \<meta>, 不常用的是：\<area> \<base> \<col> \<command> \<embed> \<keygen> \<param> \<source> \<track> \<wbr>

### 使用`link`和`@import`区别
页面导入样式时，使用link和@import有什么区别？
强烈建议使用link标签，慎用@import方式。这样可以避免考虑@import的语法规则和注意事项，避免产生资源文件下载顺序混乱和http请求过多的烦恼。
1. link属于HTML标签，而@import是CSS提供的;
1. 页面被加载的时，link会同时被加载，@import引入的 CSS 将在页面加载完毕后被加载。;
1. import只在IE5以上才能识别，而link是HTML标签，无兼容问题;
1. link方式的样式的权重 高于@import的权重

### html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？
* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
1. 绘画 canvas;
2. 用于媒介回放的 video 和 audio 元素;
3. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
4. 用来保存当前会话信息的sessionStorage，数据在浏览器关闭后自动删除;
5. 语意化更好的内容元素，比如 article、footer、header、nav、section;
6. 表单控件，calendar、date、time、email、url、search;
7. 新的技术webworker, websocket, Geolocation;

* 移除的元素：<br>
1. 纯表现的元素：basefont，big，center，font, s，strike，tt，u;<br>
2. 对可用性产生负面影响的元素：frame，frameset，noframes；

* 支持HTML5新标签：
1. IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。
2. 也可以直接使用成熟的框架、比如html5shim;

* 如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素

### HTML语义化
用正确的标签做正确的事情。
优点：
1. html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
2. 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
3. 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
4. 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

### title与h1的区别、b与strong的区别、i与em的区别？
1. title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；
1. strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：\<strong>会重读，而\<B>是展示强调内容。
1. i内容展示为斜体，em表示强调的文本；
  Physical Style Elements -- 自然样式标签, 重在视觉作用<br>
  b, i, u, s, pre<br>
  Semantic Style Elements -- 语义样式标签, 重在含义<br>
  strong, em, ins, del, code<br>
  应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。<br>

### 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？

1. 在线的情况下，浏览器发现html头部有`manifest`属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
1. 离线的情况下，浏览器就直接使用离线存储的资源。

### iframe缺点
iframe缺点：
1. iframe会阻塞主页面的`Onload`事件；
2. 搜索引擎的检索程序无法解读这种页面，不利于SEO;
3. iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。
### `Label`的作用是什么？是怎么用的？

\<label> 标签为 input 元素定义标注（标记）, 提供焦点绑定。
label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。用for属性绑定id。
```html
<form>
<label for="male">Male</label>
<input type="radio" name="sex" id="male" />
<br />
<label for="female">Female</label>
<input type="radio" name="sex" id="female" />
</form>
```

### Cookie隔离

cookie隔离技术和传统的多域名拆分请求，提高浏览器并发请求数有点类似，均是采用多域名来处理请求。

传统做法是将css，js，图片等静态文件放在多个域名下面请求，这样就可以跨过浏览器对统一主机名并发连接数的限制，提高整体并发请求量。

cookie隔离技术则是通过使用多个非主要域名来请求静态文件，如果静态文件都放在主域名下，那静态文件请求的时候带有的cookie的数据提交给server是非常浪费的，还不如隔离开。

因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入webserver，也减少了webserver对cookie的处理分析环节，提高了webserver的http请求的解析速度。

## CSS
### 盒子模型

W3C标准盒子模型，content(内容)，padding(内边距)，border(边框)，margin(外边距)组成

以margin：10px； border：2px； padding：5px； width：200px；height：100px 为例

则整个盒子模型的宽是：10px*2 + 2px*2 + 5px*2 + 200px = 234px

则整个盒子模型的高是：10px*2 + 2px*2 + 5px*2 + 100px = 134px

<img src="http://lrun1124.github.io/img/cssbase1/boxModelW3C.jpg"/>

* CSS的盒子模型，低版本IE的盒子模型有什么不同的？

旧IE，主要是指IE5和（IE6的怪异模式），content部分的width和height是把padding和border也算了进去

整个盒子模型的宽是： margin*2 + width（严格来说是：margin-left + width + margin-right

整个盒子模型的高是： margin*2 + height（严格来说是：margin-left + height + margin-right）

<img src="http://lrun1124.github.io/img/cssbase1/boxModelOldIE.jpg"/>

### CSS选择器

1. id选择器（# myid）
1. 类选择器（.myclassname）
1. 标签选择器（div, h1, p）
1. 相邻选择器（h1 + p）
1. 子选择器（ul > li）
1. 后代选择器（li a）
1. 通配符选择器（ * ）
1. 属性选择器（a[rel = "external"]）
1. 伪类选择器（a:hover, li:nth-child）

### display的值及作用

1. block       	块类型。默认宽度为父元素宽度，可设置宽高，换行显示。
1. none        	缺省值。象行内元素类型一样显示。
1. inline      	行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。
1. inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。
1. list-item   	象块类型元素一样显示，并添加样式列表标记。
1. table       	此元素会作为块级表格来显示。
1. inherit     	规定应该从父元素继承 display 属性的值。

### position属性（定位原点）

1. absolute 生成绝对定位的元素，相对于值不为static的第一个父元素进行定位。
1. fixed （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。
1. relative 生成相对定位的元素，相对于其正常位置进行定位。
1. static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
1. inherit 规定从父元素继承 position 属性的值。

### 居中div

#### 水平居中

- 给div设置一个width，然后设置margin:0 auto;

```css
div {
	width: 300px;
	margin: 0 auto;
}
```

- 让绝对定位的div居中

```css
div {
	positive: absolute;
	width: 300px;
	height: 300px;
	margin: auto;
	top: 0;
	bottom: 0;
	left: 0;
	right: 0;
}
```

#### 水平垂直居中

- 若已知容器的宽300px,高400px,则先用top和left将容器左上角定位到中心点位置，再通过设置margin移动div中心点到居中的位置

```css
div {
	position: relative;	/* 相对定位或绝对定位均可 */
	width: 300px;
	height: 400px;
	top: 50%;
	left: 50%;
	margin: -200px 0 0 -150px;	/* 外边距为自身宽高的一半的负数 */
}
```

- 未知容器宽高，使用transform属性，定义2D转换

```css
div {
	position: relative;	/* 相对定位或绝对定位均可 */
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);	/* 通过translate定义2D转换 */
}
```

- flex布局

```css
 .container {
 	display: flex;
 	align-items: center; 		/* 垂直居中 */
 	justify-content: center;	/* 水平居中 */

 }
 .container div {
 	width: 100px;
 	height: 100px;
 	background-color: pink;		/* 方便看效果 */
 }
```

#### Flexbox（弹性盒布局模型)

一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。

较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。
采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。
它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。
常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做居中，能对不同屏幕大小自适应。
在布局上有了比以前更加灵活的空间

如何兼容低版本浏览器：手动实现响应式，为低版本浏览器些resize函数，根据浏览器窗口大小使用不同样式

### 用纯css创建三角形

```css
//设置内容高宽为0，利用下边框border
div {
	width: 0;	//若不为0则为梯形
	height: 0;
	border-width: 20px;
	border-style: solid;
	border-color: transparent transparent red transparent;
}
```

### 清除浮动

当容器的高度为auto时，若容器内部含有浮动元素，则容器的高度不能自动伸长，使得内容溢出到容器外部从而影响页面布局

```css
//会产生浮动问题的代码
.news {
  background-color: gray;
  border: solid 1px black;
  }

.news img {
  float: left;
  }

.news p {
  float: right;
  }

<div class="news">
<img src="news-pic.jpg" />
<p>some text</p>
</div>
```
清除浮动的方法可以分为两大类：

#### 利用clear属性

1.使用带clear属性的空元素

```css
//会产生浮动问题的代码
.news {
  background-color: gray;
  border: solid 1px black;
  }

.news img {
  float: left;
 }

.news p {
  float: right;
 }

.clear {
    clear: both;
 }

<div class="news">
<img src="news-pic.jpg" />
<p>some text</p>
<div class="clear"></div>
</div>
```

2.若浮动元素后面有元素，给浮动元素后面的元素加clear属性

```css
.news {
  background-color: gray;
  border: solid 1px black;
  }

.news img {
  float: left;
 }

.news p {
  float: right;
 }

.content {
	clear: both;
 }

<div class="news">
<img src="news-pic.jpg" />
<p>some text</p>
<div class="content"></div>
</div>
```

3.使用CSS的:after伪元素

```css
//通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格"020"或点"."，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout
.news {
  background-color: gray;
  border: solid 1px black;
  }

.news img {
  float: left;
  }

.news p {
  float: right;
  }

.clearfix::after{
  content: "020"; 
  display: block; 
  height: 0; 
  clear: both; 
  visibility: hidden;  
  }

.clearfix {
  /* 触发 hasLayout */ 
  zoom: 1; 
  }

<div class="news clearfix">
<img src="news-pic.jpg" />
<p>some text</p>
</div>
```

#### 触发浮动元素父元素的BFC 

(Block Formatting Contexts, 块级格式化上下文)，使该父元素可以包含浮动元素

1.给浮动元素的容器添加overflow:hidden;或overflow:auto

```css
.news {
  background-color: gray;
  border: solid 1px black;
  overflow: hidden;
}

.news img {
  float: left;
}

.news p {
  float: right;
}

.clear {
	clear: both;
}

<div class="news">
<img src="news-pic.jpg" />
<p>some text</p>
<div class="clear"></div>
</div>
```

2.给浮动的元素的容器添加浮动

但是这样会使其整体浮动，影响布局，不推荐使用

#### 总结

在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。

最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。

### CSS优化、提高性能的方式
<br/>
- 选择器效率优化

读取选择器的原则是从右到左。因此，我们书写的右边的最后一个选择器，被称作关键选择器，对于效率有决定性影响。

1. 避免使用通配符
1. 不使用标签名或类名修饰ID规则：如果规则使用ID选择器作为关键选择器，不要给规则添加标签名。因为ID本身就是唯一的，添加标签名会不必要地降低匹配效率。
1. 不使用标签名修饰类：相较于标签，类更具独特性。
1. 尽量选择最具体的方式：造成低效的最简单粗暴的原因就是在标签上使用太多规则。给元素添加类可以更快细分到类方式，可以减少规则去匹配标签的时间。
1. 关于后代选择器和子选择器：避免使用后代选择器，非要用的话建议用子选择器代替，但子选择器也要慎用，标签规则永远不要包含子选择器。
1. 利用可继承性：没必要在一般内容上声明样式。
1. 提取项目的通用公有样式，增强可复用性；
1. 按模块编写组件；增强项目的协同开发性、可维护性和可扩展性；
1. 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）。

### 浏览器解析选择器过程

样式系统从关键选择器开始，然后向左移查找规则选择器的祖先元素，只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。

### 全屏滚动原理

1. 计算当前浏览器屏幕高度(document.body.clientHeight)，每次翻页显示的内容高度即为屏幕高度
2. 对鼠标滚轮事件进行监听，注意滚轮事件的浏览器兼容问题。
3. 加入时间控制，如果不加滚动会过于灵敏，一次翻好几屏

参考代码：
```html
//html
<div id="wrap">
    <div id="main">
        <div id="page1" class="page"></div>
        <div id="page2" class="page"></div>
        <div id="page3" class="page"></div>
        <div id="page4" class="page"></div>
    </div>
</div>
```

```css
//css
<style type="text/css">
html,body{
    height:100%;
}
body,ul,li,a,p,div{padding:0px; margin:0px; font-size:14px;}
#wrap{
    overflow: hidden;
    width:100%;
}
#main{
    height:2944px;
    top:0;
    position: relative;
}
.page{
    width:100%;
    margin:0;
}
#page1{
    background:#E4E6CE;
}
#page2{
    background:#6CE26C;
}
#page3{
    background:#BF4938;
}
#page4{
    background:#2932E1;
}
</style>
```

```html
//js
<script type="text/javascript">
    var wrap = document.getElementById("wrap");
    var main = document.getElementById("main");
    var hei = document.body.clientHeight;
    wrap.style.height = hei + "px";
    var obj = document.getElementsByTagName("div");
    for(var i=0;i<obj.length;i++){
        if(obj[i].className == 'page'){
             obj[i].style.height = hei + "px";
        }
    }
    //如果不加时间控制，滚动会过度灵敏，一次翻好几屏
    var startTime = 0, //翻屏起始时间  
        endTime = 0,  
        now = 0;     
    //浏览器兼容      
    if ((navigator.userAgent.toLowerCase().indexOf("firefox")!=-1)){   
        document.addEventListener("DOMMouseScroll",scrollFun,false);        
    }  
    else if (document.addEventListener) {  
        document.addEventListener("mousewheel",scrollFun,false);  
    }  
    else if (document.attachEvent) {  
        document.attachEvent("onmousewheel",scrollFun);   
    }  
    else{  
        document.onmousewheel = scrollFun;  
    }  

    //滚动事件处理函数
    function scrollFun(event){
        startTime = new Date().getTime();  
        var delta = event.detail || (-event.wheelDelta);  
        //mousewheel事件中的 “event.wheelDelta” 属性值：返回的如果是正值说明滚轮是向上滚动
        //DOMMouseScroll事件中的 “event.detail” 属性值：返回的如果是负值说明滚轮是向上滚动
        if ((endTime - startTime) < -1000){
            if(delta>0 && parseInt(main.offsetTop) > -(hei*3)){
                //向下滚动
                now = now - hei;
                toPage(now);
        } 
            if(delta<0 && parseInt(main.offsetTop) < 0){
                //向上滚动
                    now = now + hei;
                    toPage(now);
            }
             endTime = new Date().getTime();  
        }
           else{  
                event.preventDefault();    
            }    
    }
     function toPage(now){        
         $("#main").animate({top:(now+'px')},1000);     //jquery实现动画效果
         //setTimeout("main.style.top = now + 'px'",1000);     javascript 实现动画效果
    }   
</script>
```

### 伪类和伪元素

定义：
- CSS 伪类用于向某些选择器添加特殊的效果。
- CSS 伪元素用于将特殊的效果添加到某些选择器。

<img src="http://lrun1124.github.io/img/cssbase1/cssbase-class.jpg"/>
<img src="http://lrun1124.github.io/img/cssbase1/cssbase-element.jpg"/>

伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。伪元素和伪类之所以这么容易混淆，是因为他们的效果类似而且写法相仿，但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。

```css
:Pseudo-classes
::Pseudo-elements
```

但因为兼容性的问题，所以现在大部分还是统一的单冒号，但是抛开兼容性的问题，在书写时应该尽可能养成好习惯，区分两者。

### 元素竖向的百分比

对于竖直方向的margin和padding，参照父元素的宽度。
对于水平方向的margin和padding，也是参照父元素的宽度

## 性能优化

### 性能优化策略
#### 服务器端
1. 图片服务器，图片压缩，webP，wekpack图片压缩
1. Ngnix

#### request层面
1. 减少http请求次数
1. http Keep-alive 处理好timeout
1. cookie隔离

#### html层面布局
1. 使用dsn-prefetch, dsn缓存减少dsn获取时间
1. preload, prefetch, async, defer优化js文件加载和执行
1. 模块化JS打包

#### JS端
1. 减少回流代码，减少dom直接操作，读取引起回流属性
1. 用requestAnimationFrame加强网页的流畅性
1. 使用transform操作动画
1. 必要时使用display:none再修改样式
1. 多次append可以先放到一个临时页面再插入页面
1. localstorge和sessionstorage

#### css端
1. 尽量使用class修改，减少js直接修改css
1. 使用transform操作动画
1. 避免使用通配符，不使用标签名或类名修饰ID规则
1. 尽量选择最具体的方式，利用关键选择器
1. 使用transform操作动画

## 浏览器，渲染引擎，JS内核（V8）

## 安全
### Web安全及防护原理, sql注入, XSS, CSRF

#### SQL注入

通过把SQL插入Web表单欺骗服务器执行恶意SQL, SQL 注入漏洞属于后端的范畴，但前端也可做体验上的优化

1. 不要相信用户输入，利用正则等方式对输入的合法性进行判断，格式，长度，特殊字符等。
1. 不要使用动态拼装SQL，使用参数化的SQL或存储过程进行数据库操作
1. 不要使用管理员权限连接数据库，应为每个应用分配单独的权限有限的数据库连接
1. 不要明文存放敏感信息，加密或Hash

#### XSS(cross-site scripting)

攻击者向Web页面中恶意插入html标签或Js代码，比如攻击者在页面中插入一个看似安全的链接，用户点击后窃取cookie和用户输入信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

- 存储区：恶意代码存放的位置。
- 插入点：由谁取得恶意代码，并插入到网页上。

<img src="http://lrun1124.github.io/img/summary/xss_type.png"/>

 * 存储型 XSS

1. 攻击者将恶意代码提交到目标网站的数据库中。
1. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
1. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
1. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

* 反射型 XSS

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
1. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
1. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
1. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

* DOM 型 XSS

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
1. 用户打开带有恶意代码的 URL。
1. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
1. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

策略:

1. 用户输入合法性检测， 内容长度控制等
1. 避免拼接 HTML。前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。
1. 利用模板引擎转义。 如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。比如Java，常用的转义库为 org.owasp.encoder，JS使用doT.js、ejs、FreeMarker
1. HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，验证码：防止脚本冒充用户提交危险操作
1. 使用XSS扫描工具，checkmarx等

#### CSRF（Cross-site request forgery），跨站请求伪造

攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账...造成的问题包括：个人隐私泄露以及财产安全

要完成一次CSRF攻击，受害者必须依次完成两个步骤：<br/>
1. 登录受信任网站A，并在本地生成Cookie。
2. 在不登出A的情况下，访问危险网站B。

流程：
1. 受害者登录 a.com，并保留了登录凭证（Cookie）
1. 攻击者引诱受害者访问了 b.com
1. b.com 向 a.com 发送了一个请求：a.com/act=xx（浏览器会默认携带 a.com 的 Cookie）
1. a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
1. a.com 以受害者的名义执行了 act=xx
1. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作

防御：
1. CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。
1. CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。
1. 保证页面的幂等性，后端接口不要在GET页面中做用户操作。

#### Input_Path_Not_Canonicalized
#### Absolute_Path_Traversal
Absolute_Path_Traversal : When the web server returns information about errors in a web application, it is much easier for the attacker to guess the correct locations.

The following URLs may be vulnerable to this attack:
```
http://testsite.com/get.asp?f=test
```

An attacker can execute this attack like this:
```
http://testsite.com/get.asp?f=/etc/passwd
```
#### SSRF

### 对称/非对称加密，公钥和私钥
基本概念:

1. 对称加密, 最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。
1. 非对称加密， 非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）
1. 密钥对，在非对称加密技术中，有两种密钥，分为私钥和公钥，私钥是密钥对所有者持有，不可公布，公钥是密钥对持有者公布给他人的。
1. 摘要，对需要传输的文本，做一个HASH计算，一般采用SHA1，SHA2来获得。
1. 签名，使用私钥对需要传输的文本的摘要进行加密，得到的密文即被称为该次传输过程的签名。
1. 签名验证，数据接收端，拿到传输文本，但是需要确认该文本是否就是发送发出的内容，中途是否曾经被篡改。因此拿自己持有的公钥对签名进行解密（密钥对中的一种密钥加密的数据必定能使用另一种密钥解密。），得到了文本的摘要，然后使用与发送方同样的HASH算法计算摘要值，再与解密得到的摘要做对比，发现二者完全一致，则说明文本没有被篡改过。
1. 证书中心（certificate authority，简称CA), CA用自己的私钥，对发送者公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate），发送时连同签名一起发送

对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。而非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

以Alice和银行之间的通信为例，这同时也是https协议的简略过程：

1. Alice向Bank请求公钥
1. Bank网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给Alice的浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息
1. Alice的浏览器获得证书后验证合法性，客户端（浏览器）的"证书管理器"，有"受信任的根证书颁发机构"列表，客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。
1. 若证书合法，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密，这就是对称加密的秘钥。接下来会进行握手验证，使用约定好的HASH算法加密一段握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的对称加密的秘钥（使用公钥加密过的）+ 加密的握手消息发送给Bank。 若不合法则发出警告。
1. Bank使用私钥解密得到对称秘钥，使用秘钥解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 然后使用密码加密一段握手消息，发送给浏览器。 
1. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，Alice和Bank使用对称秘钥互相传输数据。

<img src="http://lrun1124.github.io/img/jsbase4/Alice&Bank.png"/>

HTTPS一般使用的加密与HASH算法如下：

非对称加密算法：RSA，DSA/DSS

对称加密算法：AES，RC4，3DES 

HASH算法：MD5，SHA1，SHA256



